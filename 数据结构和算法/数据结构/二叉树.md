---
title: 数据结构和算法
date: 2022/01/22 18:12:25  
tags:
- 数据结构
- 算法
- java
- 二叉树
- kmp
- B树
categories: 数据结构和算法
thumbnail: https://tse1-mm.cn.bing.net/th/id/R-C.680beccb8a73a1599965c5f1ee78de45?rik=ktSYW8q%2bHNQ%2fDQ&riu=http%3a%2f%2fhdfs.hdmool.com%2fhdfs3%2fM00%2f00%2f08%2fwKgADVycfdOAZmpRAAEVbyEMsYs676.jpg&ehk=amHevLJvpo1vNq5ywCLdwMXgA30XM1L0M5klygNCOr8%3d&risl=&pid=ImgRaw&r=0
cover: https://tse1-mm.cn.bing.net/th/id/R-C.680beccb8a73a1599965c5f1ee78de45?rik=ktSYW8q%2bHNQ%2fDQ&riu=http%3a%2f%2fhdfs.hdmool.com%2fhdfs3%2fM00%2f00%2f08%2fwKgADVycfdOAZmpRAAEVbyEMsYs676.jpg&ehk=amHevLJvpo1vNq5ywCLdwMXgA30XM1L0M5klygNCOr8%3d&risl=&pid=ImgRaw&r=0
---



# 数据结构-（哈希表）

## 哈希表基本介绍

<!-- more -->

散列表（Hash table，也叫哈希表），是根据关键码值（Key value）而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。

结构：

![image-20220117120402950](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220117120402950.png)



**哈希表实现**：

​	数组+链表

​	数组+二叉树

分析

![image-20220117122742359](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220117122742359.png)

哈希表自实现

```java
package com.wudidemiao.study.hash;

/**
 * @author wudidemiaoa
 * @date 2022/1/17
 * @apiNote
 */
public class SinceTheImplHash {
    public static void main(String[] args) {
        HashTableImpl hashTable = new HashTableImpl(5);
        hashTable.add(new Emp(1, "张三"));
        hashTable.add(new Emp(2, "李四"));
        hashTable.add(new Emp(3, "王五"));
        hashTable.add(new Emp(6, "炸弹"));
        hashTable.list();
        hashTable.getById(4);
        hashTable.removeByid(6);
        hashTable.removeByid(1);
        hashTable.removeByid(1);
        hashTable.list();
    }
}

class HashTableImpl {
    private EmplinkedList[] emplinkedLists;

    private int size;

    public HashTableImpl(int size) {
        this.size = size;
        ;
        this.emplinkedLists = new EmplinkedList[size];
        for (int i = 0; i < size; i++) {
            this.emplinkedLists[i] = new EmplinkedList();
        }
    }

    public void add(Emp emp) {
//        根据 员工的id，得到员工应该添加到那条链表
        int hash = hash(emp.id);
        emplinkedLists[hash].add(emp);
    }

    public void list() {
        for (int index = 0; index < emplinkedLists.length; index++) {
            emplinkedLists[index].list(index);
        }
    }

    public void getById(int id) {
        int hash = hash(id);
        Emp byId = emplinkedLists[hash].getById(id);
        if (byId == null) {
            System.out.println("没有找到");
        } else {
            System.out.println("找到了" + byId);
        }
    }
    public void removeByid(int id) {
        int hash = hash(id);
        Emp byId = emplinkedLists[hash].removeById(id);
        if (byId == null) {
            System.out.println("没有找到");
        } else {
            System.out.println("找到了" + byId);
        }
    }

    public int hash(int id) {
        return id % size;
    }
}

// 链表
class EmplinkedList {
    private Emp head;  // 头指针，指向当前链表的第一个雇员

    //    添加雇员，id是自增长的
    public void add(Emp emp) {
        if (head == null) {
            head = emp;
            return;
        }
//        如不是第一个，添加辅助指针，到最后一个
        Emp curEmp = head;
        while (true) {
            if (curEmp.next == null) {
                break;
            }

            curEmp = curEmp.next;  // 后移
        }
        curEmp.next = emp;
    }

    public void list(int index) {
        System.out.println();
        if (head == null) {
            System.out.println("第" + index + "条链表为空,编号：");
            return;
        }
        System.out.println("第" + index + "条链表信息为：");
        Emp curEmp = head; //辅助指针
        while (true) {
            System.out.printf("第" + index + "条 =>id=%d链表 name=%s\t", curEmp.id, curEmp.name);
            if (curEmp.next == null) {
                break;
            }
            curEmp = curEmp.next;  // 后移
        }
    }

    public Emp removeById(int id){
        if (head == null) {
            System.out.println("链表为空");
            return null;
        }
        Emp curEmp = head; //辅助指针
        Emp prep = curEmp;
        while (true) {
            if (curEmp == null) {
                break;
            }
            if (curEmp.id == id) {
                if(prep == curEmp){
                    head = curEmp.next;
                }else {
                    prep.next = curEmp.next;
                }
                curEmp.next = null;
                break;
            }
            prep = curEmp;
            curEmp = curEmp.next;  // 后移
        }
        return curEmp;
    }

    public Emp getById(int id) {
        if (head == null) {
            System.out.println("链表为空");
            return null;
        }
        Emp curEmp = head; //辅助指针
        while (true) {
            if (curEmp.id == id) {
                break;
            }
            curEmp = curEmp.next;  // 后移
            if (curEmp == null) {
                break;
            }
        }
        return curEmp;
    }
}

// 表示一个雇员
class Emp {
    public int id;

    public String name;

    public Emp next; // next默认为null

    public Emp(int id, String name) {
        this.id = id;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Emp{" +
                "id=" + id +
                ", name='" + name;
    }
}

```

# 数据结构-> 树结构基础算法

## 树

**为什么需要树这种数据结构**

1. 数组存储方式的分析
   优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。
   缺点：如果要检索具体某个值，或者插入值（按一定顺序）会整体移动，效率较低[际意图]
2. 链式存储方式的分析
   优点：在一定程度上对数组存储方式有优化（比如：插入一个数值节点，只需要将插入节点，链接到链表中即可，删除效率也很好）。
   缺点：在进行检索时，效率仍然较低，比如（检索某个值，需要从头节点开始遍历）
3. 树存储方式的分析又删家&
   能提高数据存储，读取的效率，比如利用二叉排序树（Binary Sort Tree），既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。

**二叉排序树结构图**

【7，3，10，1，5，9，12】

![image-20220117142613405](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220117142613405.png)

分析一把以二叉排序树来存储数据的效率

（1）查找12，经过两次比较就找到12结点

（2）添加13，很快

（3）删除1结点

## 常用术语

![image-20220117143403041](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220117143403041.png)

树的常用术语（结合示意图理解）：

1. 节点
2. 根节点  (A)
3. 父节点 
4. 子节点
5. 叶子节点（没有子节点的节点）
6. 节点的权（节点值）
7. 路径（从root节点找到该节点的路线）
8. 层
9. 子树
10. 树的高度（最大层数）
11. 森林：多颗子树构成森林

## **二叉树的概念**

1. 树有很多种，每个节点最多只能有两个子节点的一种形式称为二又树。
2. 二叉树的子节点分为左节点和右节点。
3. ![image-20220117171258659](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220117171258659.png)
4. 如果该二叉树的所有叶子节点都在最后一层，并且结点总数=2An-1，n为层数，则我们称为满二叉树。
5. 如果该二又树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树。
6. ![image-20220117171752150](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220117171752150.png)

二叉树的前序、中序、后序遍历

前序遍历：先输出父节点，再遍历左子树和右子树

中序遍历：先遍历左子树，再输出父节点，再遍历右子树

后序遍历：先遍历左子树，再遍历右子树，最后输出父节点

**小结：看输出父节点的顺序，就确定是前序，中序还是后序**

遍历分析：

1. 创建一颗二叉树
2. 如果是前序遍历，
   1. 先输出当前节点，（初始的时候是root节点）
   2. 如果左子节点不为空，则递归前序遍历，
   3. 如果右子节点不为空，则递归继续前序遍历
3. 中序遍历
   1. 如果当前节点左子节点不为空，则递归中序遍历
   2. 输出当前节点，
   3. 如果当前节点的右子节点不为空，则递归中序遍历
4. 后序遍历
   1. 如果当前节点的左子节点不为空，则递归后序遍历
   2. 如果当前节点的右子节点不为空，则递归后序遍历
   3. 输出当前节点

代码实现

```java
// 创建节点
class HeroNode {
    private int id;
    private String name;
    //    左右默认为空
    private HeroNode left;
    private HeroNode right;

    public HeroNode(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "id=" + id +
                ", name=" + name +
                '}';
    }

    //     前序遍历
    public void preOrder() {
        System.out.println(this);  // 先输出父节点
//        递归左子树前序遍历
        if (this.left != null) {
            this.left.preOrder();
        }
        if (this.right != null) {
            this.right.preOrder();
        }
    }

    //    中序遍历
    public void inFixOrder() {
//        递归左子树前序遍历
        if (this.left != null) {
            this.left.inFixOrder();
        }
        System.out.println(this);  // 输出父节点
        if (this.right != null) {
            this.right.inFixOrder();
        }
    }

    //    后序遍历
    public void afterOrder() {
        //        递归左子树前序遍历
        if (this.left != null) {
            this.left.afterOrder();
        }
        if (this.right != null) {
            this.right.afterOrder();
        }
        System.out.println(this);  // 输出父节点
    }
}

```

## 二叉树的查找指定节点

思路分析：

使用前序、中序、后序查找指定的节点

前序查找的思路

> 1. 先判断当前节点的no是都等于查找的
> 2. 如果是相等，则返回当前节点
> 3. 如果不等，则判断当前的左子节点是否为空，部位空，则递归前序查找
> 4. 如果左递归前序查找，找到节点，则返回，否继续判断，当前的节点的右子节点是否为空，如果不空，则继续向右递归前序查找

中序查找的思路

> 1. 先判断当前节点的左子节点是否为空，不为空，则递归中序查找，找到则返回
> 2. 如找不到，则判断当前节点的no是都等于查找的，
> 3. 如果是相等，则返回当前节点
> 4. 如找不到，则继续判断当前的节点的右子节点是否为空，如果不空，则继续向右递归中序查找

后序查找的思路

>1. 先判断当前节点的左子节点是否为空，不为空，则递归后序查找，找到则返回
>2. 继续判断当前的节点的右子节点是否为空，如果不空，则继续向右递归后序查找
>3. 如找不到，则判断当前节点的no是都等于查找的，
>4. 如果是相等，则返回当前节点

代码

```java

    //    前序查找
    public HeroNode preOrderSearch(int id) {
        System.out.println("进入前序遍历");
        if (this.id == id) {
            return this;
        }
        HeroNode node = null;
        if (this.left != null) {
            node = this.left.preOrderSearch(id);

        }
        if (node != null) {
            return node;
        }

        if (this.right != null) {
            node = this.right.preOrderSearch(id);
        }
        return node;
    }


    //   中序查找
    public HeroNode infixSearch(int id) {
        HeroNode node = null;
        if (this.left != null) {
            node = this.left.infixSearch(id);
        }
        if (node != null) {
            return node;
        }
        System.out.println("进入中序查找");
        if (this.id == id) {
            return this;
        }

        if (this.right != null) {
            node = this.right.infixSearch(id);
        }
        return node;
    }

    //     后序查找
    public HeroNode postSearch(int id) {
        HeroNode node = null;
        if (this.left != null) {
            node = this.left.postSearch(id);
        }
        if (node != null) {
            return node;
        }

        if (this.right != null) {
            node = this.right.postSearch(id);
        }
        if (node != null) {
            return node;
        }
        System.out.println("进入后序查找");
        if (this.id == id) {
            return this;
        }

        return null;
    }
```

## 二叉树删除节点

二叉树-删除节点
**要求**

1. 如果删除的节点是叶子节点，则删除该节点
2. 如果删除的节点是非叶子节点，则删除该子树.
3. 测试，删除掉5号叶子节点和3号子树.

**思路分析**

1. 因为二叉树是单向的，所以是判断当前节点的子节点是否需要删除，而不能判断当前的节点是否需要删除，
2. 如果当前节点的左子节点不为空，并且左子节点就是要删除的节点，就将this.left == null;（结束删除任务）
3. 如果当前节点的右子节点不为空，并且右子节点就是要删除的节点，就将this.right== null;（结束删除任务）
4. 如第二步和第三步没有删除节点，那么我们就需要向左子树进行递归删除
5. 如第四步没有删除节点，那么我们就需要向右子树进行递归删除
6. 考虑如果树是空树root，如果只有一个root结点，则等价将二叉树置空。

代码实现

```
   public boolean remove(int id) {
        if (this.left != null) {
            if (this.left.id == id) {
                this.left = null;
                return true;
            }
        }

        if (this.right != null) {
            if (this.right.id == id) {
                this.right = null;
                return true;
            }
        }

        return  (this.left !=null&&this.left.remove(id)) || (this.right !=null && this.right.remove(id));
    }
```

## 顺序存储二叉树

顺序存储二叉树的概念

基本说明：

从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组，看下面的示意图。

![image-20220117193926194](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220117193926194.png)

要求：

1. 右图的二叉树的结点，要求以数组的方式来存放arr[1，2，3，4，5，6，6]
2. 要求在遍历数组arr时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成结点的遍历

顺序存储二叉树的特点：

1. 顺序二叉树通常只考虑完全二叉树
2. 第n个元素的左子节点为2*n+1
3. 第n个元素的右子节点为2*n+21
4. 第n个元素的父节点为（n-1）/2
5. n：表示二叉树中的第几个元素（按0开始编号 如上图所示）

代码

```
package com.wudidemiao.study.tree;

/**
 * @author wudidemiaoa
 * @date 2022/1/17
 * @apiNote
 */
public class ArrBinaryTreeDemo {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6, 7};
        ArrBinaryTree arrBinaryTree = new ArrBinaryTree(arr);
        arrBinaryTree.preOrder();
    }
}

class ArrBinaryTree {
    private int[] arr;

    public ArrBinaryTree(int[] arr) {
        this.arr = arr;
    }

    public void preOrder(){
        preOrder(0);
    }

    //    编写方法，完成顺序存储二叉树的前序遍历
    public void preOrder(int order) {
        if (arr == null && arr.length == 0) {
            System.out.println("数组为空，不能按照二叉树的前序遍历。");
        }
        System.out.println(arr[order]);
//        向左前序遍历
        if (order * 2 + 1 < arr.length) {
            preOrder(order * 2 + 1);
        }

//        向右递归遍历
        if (order * 2 + 2 < arr.length) {
            preOrder(order * 2 + 2);
        }
    }
}

```

**八大排序算法中的堆排序，就会使用到顺序存储二叉树**



## 线索化二叉树

将数列{1，3，6，8，10，14}构建成一颗二又树.

![image-20220118113956829](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220118113956829.png)

问题分析：
1）当我们对上面的二叉树进行中序遍历时，数列为（8，3，10，1，6，14}
2）但是6，8，10，14这几个节点的左右指针，并没有完全的利用上。
3）如果我们希望充分的利用各个节点的左右指针，让各个节点可以指向自己的前后节点怎么办？
4）解决方案-线索二叉树

### 基本介绍

线索二叉树基本介绍

1. n个结点的二叉链表中含有n+1公式 2n-（n-1）=n+1 个空指针域。利用二又链表中的空指针域，存放指向结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为“线索"）
2. 这种加上了线索的二又链表称为线索链表，相应的二又树称为线索二叉树（Threaded BinaryTree）。根据线索性质的不同，线索二叉树可分为**前序线索二叉树、中序线索二叉树和后序线索二叉树**三种
3. 一个结点的前一个结点，称为前驱结点
4. 一个结点的后一个结点，称为后继结点

### 思路步奏

线索二叉树应用案例

应用案例说明：将下面的二又树，进行中序线索二叉树。中序遍历的数列为{8，3，10，1，14，6}

![image-20220118122617382](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220118122617382.png)

**说明：当线索化二叉树后，Node节点的属性left和right，有如下情况：**

1. left指回的是左子树，也可能是指向的前驱节点，比如①节点left指向的左子树，而①节点的left指间的就是前驱点.
2. right指向的是右子树，也可能是指向后继节点，比如①节点right指向的是右子树，而⑥节点的right指向的是后继节点.

代码和遍历是一起的

### 线索化二叉树的遍历

说明：对前面的中序线索化的二叉树，进行遍历

分析：因为线索化后，各个结点指向有变化，因此原来的遍历方式不能使用，这时需要使用新的方式遍历线索化二叉树，各个节点可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率。**遍历的次序应当和中序遍历保持一致。**

代码

```java
package com.wudidemiao.study.tree.threadedbinarytree;

/**
 * @author wudidemiaoa
 * @date 2022/1/18
 * @apiNote
 */
public class ThreadedBinaryTreeDemo {
    public static void main(String[] args) {
//        测试中序线索化二叉树功能
        HeroNode root = new HeroNode(1, "tom");
        HeroNode node2 = new HeroNode(3, "jack");
        HeroNode node3 = new HeroNode(6, "tom");
        HeroNode node4 = new HeroNode(8, "tom");
        HeroNode node5 = new HeroNode(10, "tom");
        HeroNode node6 = new HeroNode(14, "tom");

//        二叉树，手动创建
        root.setLeft(node2);
        node2.setLeft(node4);
        node2.setRight(node5);
        root.setRight(node3);
        node3.setLeft(node6);

        BinaryTree binaryTree = new BinaryTree();
        binaryTree.setHead(root);
        binaryTree.threadedNodes(root);
        System.out.println();

//        当线索化二叉树后，不能在使用原来的遍历方法，
        binaryTree.threadedList();
    }
}


// 定义一个ThreadBinaryTree 实现了线索化功能的二叉树
class BinaryTree {
    private HeroNode root;
    //    为了实现线索化，需要创建一个指向当前节点的前驱节点的引用
//    pre 总是保留保留前一个节点
    private HeroNode pre = null;

    public void setHead(HeroNode root) {
        this.root = root;
    }

    /**
     * 遍历中序线索化的二叉树
     */
    public void threadedList() {
//        定义一个变量，存储当前遍历的节点
        HeroNode node = root;
        while (node != null) {
//            循环的找到leftType=1的节点
//            后面随着遍历而变化，因为当leftType==1时，说明改节点时按照线索化处理后的有效节点，
            while (node.getLeftType() == 0) {
                node = node.getLeft();
            }
//           打印当前节点
            System.out.println(node);
//            如果当前节点的右指针指向的是后置节点
            while (node.getRightType() == 1) {
                node = node.getRight();
                System.out.println(node);
            }
//            替换这个遍历的节点
            node = node.getRight();
        }
    }

    /**
     * 编写对二叉树中序线索化的方法
     *
     * @param node 当前需要线索化的节点
     */
    public void threadedNodes(HeroNode node) {
        if (node == null) {
            return;
        }
//        先线索化左子树
        if (node.getLeft() != null) {
            threadedNodes(node.getLeft());
        }
//        在线索化处理当前节点

//        处理当前结点的前驱节点
        if (node.getLeft() == null) {
//          让当前节点的左执政指向前驱节点
            node.setLeft(pre);
//            修改当前做执政的类型,指向前驱节点
            node.setLeftType(1);
        }

        //        处理当前结点的后驱节点
        if (pre != null && pre.getRight() == null) {
//          让当前节点的左执政指向前驱节点
            pre.setRight(node);
//            修改前驱节点的右执政类型
            pre.setRightType(1);
        }
//        每处理一个节点后，让当前节点是下一个节点的前驱节点
        pre = node;

//        让前驱节点的右指针指向当前的节点

//        在线索化处理右子树
        threadedNodes(node.getRight());
    }

    //    前序遍历
    public void preOrder() {
        if (root != null) {
            root.preOrder();
        } else {
            System.out.println("二叉树为空，无法遍历");
        }
    }

    //    中序遍历
    public void infixOrder() {
        if (root != null) {
            root.inFixOrder();
        } else {
            System.out.println("二叉树为空，无法遍历");
        }
    }

    //    hou序遍历
    public void postOrder() {
        if (root != null) {
            root.afterOrder();
        } else {
            System.out.println("二叉树为空，无法遍历");
        }
    }

    //    前序查找
    public HeroNode preOrderSearch(int no) {
        if (root != null) {
            return root.preOrderSearch(no);
        } else {
            return null;
        }
    }

    //    zhong序查找
    public HeroNode infixOrderSearch(int no) {
        if (root != null) {
            return root.infixSearch(no);
        } else {
            return null;
        }
    }

    //    后序
    public HeroNode ipostOrderSearch(int no) {
        if (root != null) {
            return root.postSearch(no);
        } else {
            return null;
        }
    }

    public void remove(int no) {
        if (root.getId() == no) {
            root = null;
            System.out.println("删除成功");
        } else {
            if (root.remove(no)) {
                System.out.println("删除成功");
            } else {
                System.out.println("删除失败");
            }
        }
    }
}


// 创建节点
class HeroNode {
    private int id;
    private String name;
    //    左右默认为空
    private HeroNode left;
    private HeroNode right;
    //    1.弱国leftType == 0，表示指向的是左子树，如果是1则表示前驱结点
//    2.如果rightType == 0，表示指向是右子树，如果是1表示指向后续结点
    private int leftType;

    public int getLeftType() {
        return leftType;
    }

    public void setLeftType(int leftType) {
        this.leftType = leftType;
    }

    public int getRightType() {
        return rightType;
    }

    public void setRightType(int rightType) {
        this.rightType = rightType;
    }

    private int rightType;


    public HeroNode(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "id=" + id +
                ", name=" + name +
                '}';
    }

    //     前序遍历
    public void preOrder() {
        System.out.println(this);  // 先输出父节点
//        递归左子树前序遍历
        if (this.left != null) {
            this.left.preOrder();
        }
        if (this.right != null) {
            this.right.preOrder();
        }
    }

    //    中序遍历
    public void inFixOrder() {
//        递归左子树前序遍历
        if (this.left != null) {
            this.left.inFixOrder();
        }
        System.out.println(this);  // 输出父节点
        if (this.right != null) {
            this.right.inFixOrder();
        }
    }

    //    后序遍历
    public void afterOrder() {
        //        递归左子树前序遍历
        if (this.left != null) {
            this.left.afterOrder();
        }
        if (this.right != null) {
            this.right.afterOrder();
        }
        System.out.println(this);  // 输出父节点
    }

    //    前序查找
    public HeroNode preOrderSearch(int id) {
        System.out.println("进入前序遍历");
        if (this.id == id) {
            return this;
        }
        HeroNode node = null;
        if (this.left != null) {
            node = this.left.preOrderSearch(id);

        }
        if (node != null) {
            return node;
        }

        if (this.right != null) {
            node = this.right.preOrderSearch(id);
        }
        return node;
    }


    //   中序查找
    public HeroNode infixSearch(int id) {
        HeroNode node = null;
        if (this.left != null) {
            node = this.left.infixSearch(id);
        }
        if (node != null) {
            return node;
        }
        System.out.println("进入中序查找");
        if (this.id == id) {
            return this;
        }

        if (this.right != null) {
            node = this.right.infixSearch(id);
        }
        return node;
    }

    //     后序查找
    public HeroNode postSearch(int id) {
        HeroNode node = null;
        if (this.left != null) {
            node = this.left.postSearch(id);
        }
        if (node != null) {
            return node;
        }

        if (this.right != null) {
            node = this.right.postSearch(id);
        }
        if (node != null) {
            return node;
        }
        System.out.println("进入后序查找");
        if (this.id == id) {
            return this;
        }

        return null;
    }

    public boolean remove(int id) {
        if (this.left != null) {
            if (this.left.id == id) {
                this.left = null;
                return true;
            }
        }

        if (this.right != null) {
            if (this.right.id == id) {
                this.right = null;
                return true;
            }
        }

        return (this.left != null && this.left.remove(id)) || (this.right != null && this.right.remove(id));
    }
}



```

# 树结构的实际应用

## 堆排序

堆排序基本介绍

1. 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为o（nlogn），它也是不稳定排序。
2. 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆，注意：没有要求结点的左孩子的值和右孩子的值的大小关系。
3. 每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆4）大顶堆举例说明

![image-20220118154648230](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220118154648230.png)

4. 小顶堆举例说明

![image-20220118155113207](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220118155113207.png)

5. 一般排序采用大顶堆，降序采用小顶堆



## **堆排序基本思想**

堆排序的基本思想是：

1. 将待排序序列构造成一个大顶堆

2. 此时，整个序列的最大值就是堆顶的根节点。

3. 将其与末尾元素进行交换，此时末尾就为最大值。

4. 然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。

   

   可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了.

图示：

原始的数组【4，6，8，5，9】

1. 假定给定无序序列结构如下

   ![image-20220118160007689](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220118160007689.png)

   

2. 此时我们从最后一个非叶子结开始（叶结点自然不用调整，第一个非叶子结点arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。

![image-20220119185654140](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220119185654140.png)

3. 找到第二个非叶节点4，由于[4，9，8]中9元素最大，4和9交换。

![image-20220119185952931](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220119185952931.png)

4. 这时，交换导致了子根[4，5，6]结构混乱，继续调整，[4，5，6]中6最大，交换4和6。

![image-20220119190137970](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220119190137970.png)

此时，我们就将一个无序序列构造成了一个大顶堆。

**步骤二将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。**

1. 将堆顶元素9和末尾元素4进行交换

![image-20220119190324308](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220119190324308.png)

2. 重新调整结构，使其继续满足堆定义

![image-20220119190405379](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220119190405379.png)

3. 再将堆顶元素8与未尾元素5进行交换，得到第二大元素8.

![image-20220119190443961](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220119190443961.png)

4. 后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序

![image-20220119190522296](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220119190522296.png)

基本思路

1. 将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆
2. 将堆顶元素与末尾元素交换，将最大元素“沉“到数组末端；
3. 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整
   +交换步骤，直到整个序列有序。

代码

```java
package com.wudidemiao.study.tree;

import java.util.Arrays;

/**
 * @author wudidemiaoa
 * @date 2022/1/19
 * @apiNote
 */
public class HeadSort {

    public static void main(String[] args) {
//        升序排列，进行大顶堆排序
        int[] arr = {4, 6, 8, 5, 9};
        headSort(arr);
    }

    //    堆排序的方法
    public static void headSort(int[] arr) {
        int tmp = 0;
        System.out.println("堆排序");
// 分布完成
//        adjustHead(arr, 1, arr.length);
//        System.out.println("第一次" + Arrays.toString(arr));  // 4 9 8 5 6
//
//        adjustHead(arr, 0, arr.length);
//        System.out.println("第二次" + Arrays.toString(arr));  // 9, 6, 8, 5, 4
        for (int i = arr.length / 2 - 1; i >= 0; i--) {
            adjustHead(arr, i, arr.length);
        }

        for (int j = arr.length - 1; j > 0; j--) {
//            交换
            tmp = arr[j];
            arr[j] = arr[0];
            arr[0] = tmp;
            adjustHead(arr, 0, j);
        }

        System.out.println("数组：" + Arrays.toString(arr));  // 9, 6, 8, 5, 4
    }

    /**
     * 将一个数组（二叉树），调整成一颗大顶堆，
     * <p>
     * 将以i对应的非叶子节点的树调整为大顶堆
     *
     * @param arr    待调整的数组
     * @param i      表示非叶子节点在数组中的索引
     * @param length 表示对多少个元素进行调整，length 实在逐渐的减小
     */
    public static void adjustHead(int arr[], int i, int length) {
// 取出当前元素的值
        int temp = arr[i];
//        开始调整
//        i1= i*2+1 i1是i节点的左子节点
        for (int i1 = i * 2 + 1; i1 < length; i1 = i1 * 2 + 1) {
            if (i1 + 1 < length && arr[i1] < arr[i1 + 1]) {  // 说明左子节点的值小于右子节点的值
                i1++;  // k指向
            }
            if (arr[i1] > temp) {  // 如果子节点大于夫节点
                arr[i] = arr[i1];  // 把较大的值付给当前节点
                i = i1;     // 把i指向i1，持续循环比较
            } else {
                break;
            }
        }

//        当for循环结束后，我们将i为夫节点的树的最大值，放在u最前面（局部）
        arr[i] = temp;
    }
}

```

## 赫夫曼树

### 基本介绍

1. 给定n个权值作为n个叶子结点，构造一棵二又树，若该树的带权路径长度（wpl）达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树（Huffman Tree），还有的书翻译为霍夫曼树。
2. 赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。

### 赫去曼树几个重要概念和举例说明

1. 路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1
2. 结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积
3. 树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL（weighted path length），权值越大的结点离根结点越近的二叉树才是最优二叉树。
4. WPL最小的就是赫夫曼树

![image-20220119204308036](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220119204308036.png)

### 赫夫曼树创建思路图解

给你一个数列{13，7，8，3，29，6，1}，要求转成一颗赫夫曼树.

思路分析：

​	构建赫夫曼树得步奏

	1. 从小到大进行排序，将每一个数据，每个数据都是一个节点，每个节点可以看成是一颗最简单得二叉树
	2. 取出根节点权值最小的两颗二叉树
	3. 组成一颗新的二叉树，该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和
	4. 再将这颗新的二叉树，以根节点的权值大小再次排序，不断重复1-2-3-4 的步奏，直到数列中，所有的数据源都被处理，就得到一颗赫夫曼树。



**图示**

![image-20220119210544300](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220119210544300.png)

![image-20220119210610607](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220119210610607.png)

![image-20220119210739515](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220119210739515.png)

![image-20220119210958973](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220119210958973.png)

### 代码创建赫夫曼树

```java
package com.wudidemiao.study.huffmantree;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

/**
 * @author wudidemiaoa
 * @date 2022/1/19
 * @apiNote
 */
public class HuffmanTree {
    public static void main(String[] args) {
        int arr[] = {13, 7, 8, 3, 29, 6, 1};
        Node huffmanTree = createHuffmanTree(arr);
    }

    //     创建赫夫曼树的方法
    public static Node createHuffmanTree(int arr[]) {
//      1.  遍历arr数组
//      2.  将arr的每个元素构建成每一个node
//        3.将Node 放入ArrayList中
        List<Node> nodes = new ArrayList<>();
        for (int i = 0; i < arr.length; i++) {
            nodes.add(new Node(arr[i]));
        }
        while (nodes.size() != 1) {
            Collections.sort(nodes);
            System.out.println("nodes=" + nodes);
//         去除权值最小的二叉树节点
            Node left = nodes.remove(0);
            Node right = nodes.remove(0);
            Node parents = new Node(left.value + right.value);
            parents.left = left;
            parents.right = right;
            nodes.add(parents);
        }
        return nodes.remove(0);
    }
}


// 创建节点类
// 为了让Node对象持续排序Collections 集合排序
class Node implements Comparable<Node> {
    //    权值
    int value;
    Node left; // 左子节点
    Node right;

    public Node(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    @Override
    public int compareTo(Node o) {
//        从小到大排序
        return this.value - o.value;
    }
}

```

## 赫夫曼编码



### **基本介绍**

1. 赫夫曼编码也翻译为哈夫曼编码（Huffman Coding），又称霍夫曼编码，是一种编码方式，属于一种程序算法
2. 赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。
3. 赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%~90%之间
4. 赫夫曼码是可变字长编码（VLC）的一种。Huffman于1952年提出一种编码方法，称之为最佳编码

### 原理刨析

> 通信领域中信息的处理方式1-定长编码

![image-20220119233352572](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220119233352572.png)

- 按照二进制来传递信息，总的长度是359（包括空格）
- [在线转码工具](https://www.mokuge.com/tool/ascito16/)

>通信领域中信息的处理方式2-变长编码

![image-20220119234535430](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220119234535430.png)

### 赫夫曼编码原理

>通信领域中信息的处理方式3-赫夫曼编码
>· i like like like java do you like a java//共40个字符（包括空格）
>· d：1y：1u：1j：2 v：20：21：4k：4e：4i：5a：5：9    //各个字符对应的个数
>· 按照上面字符出现的次数构建一颗赫夫曼树，次数作为权值.（图后）

![image-20220119235652533](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220119235652533.png)

> //根据赫夫曼树，给各个字符//规定编码，向左的路径为0/向右的路径为1，编码如下：
> o：1000 u：10010 d：100110y：100111 i：101
> a：110 k：1110 e：1111 j：0000 v：0001
> l：001：01
>
> 按照上面的赫夫曼编码，我们的“i like like like java do you like a java”字符串对应的编码为(前缀编码)（注意这里我们使用的无损压缩）
> 1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110
>
> 长度为：133说明：
> 1）原来长度是359，压缩了（359-133）/359=62.9%
> 2）此编码满足前缓编码，即字符的编码都不能是其他字符编码的前绷。不会造成匹配的多义性，无损的处理方案

注意，这个赫夫曼树根据排序方法不同，也可能不太一样，这样对应的赫夫曼编码也不完全一样，但是wpl是一样的，都是最小的，比如：如果我们让每次生成的新的二叉树总是排在权值相同的二又树的最后一个。

### 创建赫夫曼树思路

最佳实践-数据压缩（创建赫夫曼树）

将给出的一段文本，比如"i like like like java do you like a java"”，根据前面的讲的赫夫曼编码原理，对其进行数据压缩处理，

步骤1：根据赫夫曼编码压缩数据的原理，需要创建"i like like like java do you like a java”对应的赫夫曼树

思路：

1. 需要构建一个新的节点  Node{ data  存放数据 ,weight {权值} left 和right}
2. 得到字符串对应的byte[] 数组
3. 编写一个方法，将准备构建赫夫曼树的节点，放到list中，排序，然后来回构建赫夫曼树。当list中节点为1时退出，赫夫曼树构建成功

补充：补码-> 反码（符号位不变，减1得到反码）->原码（符号位不变，其他位取反，得到原码）

代码实现：和解码一起放在下面



### 赫夫曼编码->解码

最佳实践-数据解压（使用赫夫曼编码解码

使用赫夫曼编码来解码数据，具体要求是

1. 前面我们得到了赫夫曼编码和对应的编码byte[]即：[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]
2. 现在要求使用赫夫曼编码，行解码，又重新得到原来的字符串"i like like like java do you like a java

思路：解码过程，就是编码的一个逆向操作。

代码实现：

压缩文件解压文件

```java
package com.wudidemiao.study.huffmancode;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.*;

/**
 * @author wudidemiaoa
 * @date 2022/1/20
 * @apiNote
 */
public class HuffmanCode {
    public static void main(String[] args) {
//        String str = "i like like like java do you like a java";
//        huffmanZip(str.getBytes());
//        byte[] bytes = {-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28};
//        byte[] decode = decode(huffmanCodes, bytes);
//        System.out.println(new String(decode));
//        zipFile("F:\\测试文件夹\\风景 - 16.jpg", "F:\\测试文件夹\\1.zip");
        unZipFile("F:\\测试文件夹\\1.zip","F:\\测试文件夹\\dst.jpg");
    }

    public static void unZipFile(String srcFile, String dstFile) {
        try (//        创建文件的输入流
             FileInputStream is = new FileInputStream(srcFile);
             //        创建输出流
             FileOutputStream fileOutputStream = new FileOutputStream(dstFile);
             ObjectInputStream objectInputStream = new ObjectInputStream(is);) {
            byte[] o1 = (byte[])objectInputStream.readObject();
            Map<Byte,String> o = (Map<Byte,String>)objectInputStream.readObject();
            byte[] decode = decode(o, o1);
            fileOutputStream.write(decode);
            System.out.println("解压成功..");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 编写方法对文件进行压缩处理
     *
     * @param srcFile 源地址
     * @param dstFile 目标地址
     */
    public static void zipFile(String srcFile, String dstFile) {

        try ( //        创建文件的输入流
              FileInputStream is = new FileInputStream(srcFile);
              //        创建输出流
              FileOutputStream fileOutputStream = new FileOutputStream(dstFile);
              ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
        ) {
            byte[] bytes = new byte[is.available()];
//            读取文件
            is.read(bytes);
//            获取到对应的赫夫曼编码表
            byte[] bytes1 = huffmanZip(bytes);
//赫夫曼编码后的字节数组写进去
            objectOutputStream.writeObject(bytes1);
            //            这里我们可以以对象流的方式写入赫夫曼编码，是为了以后回复文件时使用
            objectOutputStream.writeObject(huffmanCodes);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

//    完成数据的解压
//    1. 先将处理后的字节数组重新先转为赫夫曼编码对应的二进制的字符串，
//    2. 赫夫曼编码对应的二进制的字符串=》 对照赫夫曼编码=》重新转为字符串

    /**
     * 完成对压缩数据的解码
     *
     * @param huffmanCodes 赫夫曼编码表
     * @param huffmanBytes 赫夫曼编码得到的字节数组
     * @return 原来的字符串对应的数组
     */
    public static byte[] decode(Map<Byte, String> huffmanCodes, byte[] huffmanBytes) {
        //.先得到 huffmanBytes对应的二进制的字符串，形式101010010111
        StringBuilder stringBuilder = new StringBuilder();
//        将byte数组转成而精致的字符串1
        for (int i = 0; i < huffmanBytes.length; i++) {
//            判断是不是最后一个字节
            boolean flag = (i == huffmanBytes.length - 1);
            String s = byteToBitString(!flag, huffmanBytes[i]);
            stringBuilder.append(s);
        }
//        System.out.println(stringBuilder.toString());
//       把字符串按照指定的和驸马编码进行解码
//        把赫夫曼编码表进行调换，因为反向查询  97->100
        Map<String, Byte> map = new HashMap<>();
        for (Map.Entry<Byte, String> stringByteEntry : huffmanCodes.entrySet()) {
            map.put(stringByteEntry.getValue(), stringByteEntry.getKey());
        }
//        创建一个集合，存放Byte
        List<Byte> bytes = new ArrayList<>();
        for (int i = 0; i < stringBuilder.length(); ) {
            int count = 1;  // 小的计数器
            boolean flag = true;
            Byte b = null;
            while (flag) {
//                取出一个字符
                String key = stringBuilder.substring(i, i + count);  // i不动，让count移动，直到匹配到一个字符
                if (map.containsKey(key)) {
                    b = map.get(key);
                    flag = false;
                } else {
                    count++;
                }
            }
            bytes.add(b);
            i += count;
        }

//        当for循环结束后List就存放了所有的字符
//        把List中的数据放到byte数组中并返回
        byte[] bytes1 = new byte[bytes.size()];
        for (int i = 0; i < bytes.size(); i++) {
            bytes1[i] = bytes.get(i);
        }
        return bytes1;
    }

    /**
     * 将一个byte转为二进制的字符串
     *
     * @param b
     * @param flag 如果是true表示需要补高位，反之不补
     * @return 是该b对应的二进制的字符串，（注意是按补码返回）
     */
    private static String byteToBitString(boolean flag, byte b) {
//        使用一个变量保存b
        int temp = b;
//       如果是正数我们还存在补高位
        if (flag)
            temp |= 256;
        String str = Integer.toBinaryString(temp); // 返回temp对应的二进制的补码
//        System.out.println(str);
        if (flag) {
            return str.substring(str.length() - 8);
        }
        return str;
    }

    /**
     * 使用一个方法将前面的方法封装起来，便于调用，
     *
     * @param bytes
     * @return 经过赫夫曼编码压缩后返回的byte数组
     */
    private static byte[] huffmanZip(byte bytes[]) {
        List<Node> nodes = getNodes(bytes);
//         根据nodes创建的赫夫曼树
        Node huffmanTree = getHuffmanTree(nodes);
//        对应的赫夫曼编码（根据赫夫曼树）
        getBinaryCode(huffmanTree, "", stringBuilder);
//        根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组
        return zip(bytes, huffmanCodes);
    }

    private static byte[] zip(byte[] bytes, Map<Byte, String> huffman) {
        StringBuilder stringBuilder = new StringBuilder();
        for (int i = 0; i < bytes.length; i++) {
            String str = huffman.get(bytes[i]);
            stringBuilder.append(str);
        }

//        将stringBuilder转位byte数组，长度
        int len = (stringBuilder.length() + 7) / 8;
//         创建1一个存储压缩后的byte数组
        byte[] by = new byte[len];
        int k = 0;
        for (int i = 0; i < stringBuilder.length(); i += 8) {  // 因为是每八位对应一个byte，所以步长应该是+8
            String strByte;
            if (i + 8 > stringBuilder.length()) {
                strByte = stringBuilder.substring(i);
            } else {
                strByte = stringBuilder.substring(i, i + 8);
            }
            by[k] = (byte) Integer.parseInt(strByte, 2);
            k++;
        }
        return by;
    }

    static StringBuilder stringBuilder = new StringBuilder();

    static Map<Byte, String> huffmanCodes = new HashMap<>();

    /**
     * 将传入的node节点的所有叶子节点的赫夫曼编码存放到huffmanCodes 集合中
     *
     * @param node          传入节点
     * @param code          路劲 ：左子节点. 0 右子节点  1
     * @param stringBuilder 适用于凭借路劲
     */
    private static void getBinaryCode(Node node, String code, StringBuilder stringBuilder) {
        StringBuilder stringBuilder1 = new StringBuilder(stringBuilder);
        stringBuilder1.append(code);
        if (node != null) {
            if (node.data == null) {
//                递归处理
//                向左递归
                getBinaryCode(node.left, "0", stringBuilder1);
                getBinaryCode(node.right, "1", stringBuilder1);
            } else {
//                叶子节点
                huffmanCodes.put(node.data, stringBuilder1.toString());
            }
        }
    }

    static List<Node> getNodes(byte[] strBytes) {
        List<Node> nodes = new ArrayList<>();
//      存储每一个byte出现的次数->map
        Map<Byte, Integer> counts = new HashMap<>();
        for (byte strByte : strBytes) {
            if (counts.containsKey(strByte)) {
                Integer integer = counts.get(strByte) + 1;
                counts.put(strByte, integer);
            } else {
                counts.put(strByte, 1);
            }
        }
//        把每个键值对转换成node对象，并加入nodes集合
        for (Map.Entry<Byte, Integer> byteIntegerEntry : counts.entrySet()) {
            nodes.add(new Node(byteIntegerEntry.getKey(), byteIntegerEntry.getValue()));
        }
        return nodes;
    }

    static Node getHuffmanTree(List<Node> nodes) {
        while (nodes.size() != 1) {
            Collections.sort(nodes);
//         去除权值最小的二叉树节点
            Node left = nodes.remove(0);
            Node right = nodes.remove(0);
            Node parents = new Node(null, left.weight + right.weight);
            parents.left = left;
            parents.right = right;
            nodes.add(parents);
        }
        return nodes.remove(0);
    }

    static class Node implements Comparable<Node> {
        Byte data;  // 存放的数据
        int weight;  // 权值  字符出现的次数
        Node left;
        Node right;

        public Node(Byte data, int weight) {
            this.data = data;
            this.weight = weight;
        }

        public void preOrder() {
            System.out.println(this);
            if (this.left != null) {
                this.left.preOrder();
            }

            if (this.right != null) {
                this.right.preOrder();
            }
        }

        @Override
        public int compareTo(Node o) {
            return this.weight - o.weight;
        }

        @Override
        public String toString() {
            return "Node{" +
                    "data=" + data +
                    ", weight=" + weight +
                    '}';
        }
    }
}
```

### 赫夫曼编码压缩文件注意事项

1. 如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化，比如视频，ppt等等文件[举例压一个p
2. 赫夫曼编码是按字节来处理的，因此可以处理所有的文件（二进制文件、文本文件）[举例压一个xm文件
3. 如果一个文件中的内容，厘复的数据不多，压缩效果也不会很明显

## 二叉排序树

**思路分析**

使用数组

1. 数组未排序，优点：直接在数组尾添加，速度快。缺点：查找速度慢.[示意图]
2. 数组排序，优点：可以使用二分查找，查找速度快，缺点：为了保证数组有序在添加新数据时，找到插入位置后，后面的数据需整体移动，速度慢。际意图]



使用链式存储-链表

不管链表是否有序，查找速度都馒，添加数据速度比数组快，不需要数据整体移动。

使用二叉排序树

### 介绍

二叉排序树：BT:（Binary Sort（Search）Tree对于二又排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大特别说明：如果有相同的值，可以将该节点放在左子节点或右子节点

比如针对前面的数据（7，3，10，12，5，1，9，对应的二叉排序树为

![image-20220120184636965](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220120184636965.png)

**二叉排序树**

二叉排序树创建和遍历

一个数组创建成对应的二叉排序树，并使用中序遍历二叉排序树，比如：数组为Ary（7，3，10，12，5，1，9），创建成对应的二叉排序树为

![image-20220120185136270](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220120185136270.png)

**二叉树的删除**

二叉排序树的删除情况比较复杂，有下面三种情况需要考虑

1. 删除叶子节点（比如：2，5，9，12）
2. 删除只有一颗子树的节点（比如：1）
3. 删除有两颗子树的节点.（比如：7，3，10）

![image-20220120191908193](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220120191908193.png)

图解二叉排序树删除节点的三种情况

1. 第一种，删除叶子节点

   1. 找到要删除的节点，targetNode
   2. 找到targetNode的父节点，parentNode
   3. 判断targetNode 是parentNode的左子节点还是右子节点，
   4. 根据前面的情况来对应删除

2. 第二种，删除只有一颗子树的节点

   1. 找到要删除节点，targetNode,
   2. 找到targetNode的父节点，parent
   3. 确定targetNode的子节点还是左子节点和右子节点
   4. targetNode 是parent 的左子节点还是右子结点
   5. 如果targetNode 是parent的左子结点
   6. targetNode 的子节点是左子结点
   7. parent.left = targetNode.left;执行删除操作

3. 第三种，删除有两颗字数的节点

   1. 找到要删除的节点，targetNode

   2. 找到targetNode 的父节点，parent

   3. 从targetNode的右子树找到最小的节点保存 temp = 12;

   4. 删除最小的节点

   5. targetNode.value=temp;

       



代码实现

```java
package com.wudidemiao.study.binarysorttree;

/**
 * @author wudidemiaoa
 * @date 2022/1/20
 * @apiNote
 */
public class BinarySortTreeDemo {
    public static void main(String[] args) {
        int[] arr = {7, 3, 10, 12, 5, 1, 9, 0};
        BinarySortTree tree = new BinarySortTree();
        for (int i : arr) {
            tree.add(i);
        }
        tree.infixOrder();
//        tree.delNode(2);
        tree.delNode(10);
        tree.infixOrder();
    }
}

class BinarySortTree {
    private Node head;

    //    查找要删除的节点
    public Node search(int value) {
        if (head == null) {
            return null;
        }
        return head.search(value);
    }

    //    查找要删除的节点的夫节点
    public Node searchParent(int value) {
        if (head == null) {
            return null;
        }
        return head.searchParent(value);
    }

    /**
     * 返回 以node为根节点的二叉排序树的最小节点的值
     * 删除node为根节点的二叉排序树的最小节点
     *
     * @param node 传入的节点（当作二叉排序树的根节点）
     * @return  返回的以node为根节点的二叉排序树的最小节点的值
     */
    public int delRight(Node node){
        Node target = node;
//        循环的查找左节点，就会找到最小值
        while (target.left !=null){
            target = target.left;
        }
//        这时target就指向最小节点
        delNode(target.value);
        return target.value;
    }

    public int delLeft(Node node){
        Node target = node;
//        循环的查找左节点，就会找到最小值
        while (target.right !=null){
            target = target.right;
        }
//        这时target就指向最小节点
        delNode(target.value);
        return target.value;
    }


    //    删除节点
    public void delNode(int value) {
        if (head == null) {
            return;
        }
//        需要先去找要删除的节点targetNode
        Node targetNode = search(value);
        if (targetNode == null) {
            return;
        }
//        如果发现当前这颗二叉排序树只有一个节点，
        if (head.left == null && head.right == null) {
            head = null;
            return;
        }

//        去查找targetNode的父节点
        Node parent = searchParent(value);
//        如果要删除的是叶子节点
        if (targetNode.left == null && targetNode.right == null) {
            if (parent.left != null && parent.left.value == value) {
                parent.left = null;
            } else if (parent.right != null && parent.right.value == value) {
                parent.right = null;
            }
            return;
        } else if (targetNode.left != null && targetNode.right != null) {  //删除目录下存在左右子树
            int minValue = delRight(targetNode.right);
            targetNode.value = minValue;
        } else { // 删除只有一颗子树的节点
            // 如果要删除的节点有左子节点
            if (targetNode.left != null) {
                if(parent==null){
                    head = targetNode.left;
                    return;
                }
                if (parent.left.value == value) {
                    parent.left = targetNode.left;
                } else if (parent.right.value == value) {
                    parent.right = targetNode.left;
                }
            } else {  // 要删除的节点有右子节点
                if(parent==null){
                    head = targetNode.right;
                    return;
                }
                if (parent.left.value == value) {
                    parent.left = targetNode.right;
                } else if (parent.right.value == value) {
                    parent.right = targetNode.right;
                }
            }
        }

    }

    public void add(int value) {
        if (head != null) {
            head.add(new Node(value));
        } else {
            head = new Node(value);
        }
    }

    public void infixOrder() {
        if (head != null) {
            head.infixOrder();
        } else {
            System.out.println("不能遍历");
        }
    }

}

class Node {
    int value;
    Node left;
    Node right;

    public Node(int value) {
        this.value = value;
    }

    /**
     * 查找要删除的节点
     *
     * @param value
     */
    public Node search(int value) {
        if (this.value == value) { // 找到该节点
            return this;
        } else if (this.value > value) {  // 如果查找的值小于当前节点，向左子树递归查找
            if (this.left == null) {
                return null;
            }
            return this.left.search(value);
        } else {
            if (this.right == null) {
                return null;
            }
            return this.right.search(value);
        }
    }

    /**
     * 查找要删除的节点的父节点
     *
     * @param value 要找的节点的值
     * @return 返回的是要删除的节点的父节点，如果没有就返回null;
     */
    public Node searchParent(int value) {
        if (this.value == value) {
            return null;
        }
        if ((this.left != null && this.left.value == value) || (this.right != null && this.right.value == value)) {
            return this;
        } else {
//            如果查找的值小于当前节点的值，并且当前节点的左子节点不为空
            if (value < this.value && this.left != null) {
                return this.left.searchParent(value);
            } else if ((value >= this.value && this.right != null)) {
                return this.right.searchParent(value);
            } else {
                return null;
            }
        }
    }

    public void add(Node node) {
        if (node == null) {
            return;
        }
        if (node.value < value) {
            if (left == null) {
                left = node;
            } else {
                this.left.add(node);
            }
        } else {
            if (right == null) {
                right = node;
            } else {
                this.right.add(node);
            }
        }
    }

    public void infixOrder() {
        if (left != null) {
            left.infixOrder();
        }
        System.out.println(this);
        if (right != null) {
            right.infixOrder();
        }
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }
}

```

## 平衡二叉树（AVL树）

看一个案例（说明二叉排序树可能的问题）

给你一个数列{1，2，34.5，6}，要求创建一颗二叉排序树BST），并分析问题所在

![image-20220120223436328](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220120223436328.png)

上边BST存在的问题分析：

1. 左子树全部为空，从形式上看，更像一个单链表
2. 插入速度没有影响
3. 查询速度明显降低因为需要依次比较），不能发挥BST的优势，因为每次还需要比较左子树，其查询速度比单链表还慢
4. 解决方案平衡二叉树（AVL）

### 基本介绍

1. 平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tre）又被称为AVL树，可以保证查询效率较高。
2. 具有以下特点：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树AⅥL、替罪羊树、Treap、伸展树等


### 构建一颗平衡二叉树

**单旋转-左旋转**

1）要求：给你一个数列，创建出对应的平衡二叉树数列{4，3，6，5，7，8}

思路：

![image-20220121095653227](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220121095653227.png)

**右旋转**

1）要求：给你一个数列，创建出对应的平衡二叉树数列{10，12，8，9，76}

思路分析：

![image-20220121104231581](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220121104231581.png)

**双旋转**

前面的两个数列，进行单旋转（即一次旋转）就可以将非平衡二叉树转成平衡二叉树，但是在某些情况下，单旋转不能完成平衡二叉树的转换。比如数列**int[]arr={10,11,7,6,8,9}；运行原来的代码可以看到，并没有转成AVL树.**
**int]arr={2,1,6,5,7,3}；∥/运行原来的代码可以看到，并没有转成AⅥL树**

![image-20220121105637890](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220121105637890.png)

>问题分析
>
>1. 当符合右旋转的条件时，
>2. 如果左子树的右子树的高度大于它的左子树的高度时
>3. 需要先对当前的这个节点的左节点进行先左旋转，
>4. 在对当前节点进行向右旋转的操作即可
>
>

代码展示

```java
package com.wudidemiao.study.avl;

/**
 * @author wudidemiaoa
 * @date 2022/1/21
 * @apiNote
 */
public class AVLTreeDemo {
    public static void main(String[] args) {
//        int[] arr = {4, 3, 6, 5, 7, 8};
//        int[] arr = {10, 12, 8, 9, 7, 6};
        int[] arr = {10, 11, 7, 6, 8, 9};
//        int[] arr = {2, 1, 6, 5, 7, 3};
//        创建一个avl树对象
        AVLTree avlTree = new AVLTree();
//        添加节点
        for (int i = 0; i < arr.length; i++) {
            avlTree.add(arr[i]);
        }
        System.out.println("中序遍历。。。");
        avlTree.infixOrder();

        System.out.println("无平衡处理之前");
        System.out.println("树高度" + avlTree.root.height());
        System.out.println("左树高度" + avlTree.root.leftHeight());
        System.out.println("右树高度" + avlTree.root.rightHeight());
        System.out.println("根树" + avlTree.root);
    }
}

//创建avl树
class AVLTree {
    Node root;

    //    查找要删除的节点
    public Node search(int value) {
        if (root == null) {
            return null;
        }
        return root.search(value);
    }

    //    查找要删除的节点的夫节点
    public Node searchParent(int value) {
        if (root == null) {
            return null;
        }
        return root.searchParent(value);
    }

    /**
     * 返回 以node为根节点的二叉排序树的最小节点的值
     * 删除node为根节点的二叉排序树的最小节点
     *
     * @param node 传入的节点（当作二叉排序树的根节点）
     * @return 返回的以node为根节点的二叉排序树的最小节点的值
     */
    public int delRight(Node node) {
        Node target = node;
//        循环的查找左节点，就会找到最小值
        while (target.left != null) {
            target = target.left;
        }
//        这时target就指向最小节点
        delNode(target.value);
        return target.value;
    }

    public int delLeft(Node node) {
        Node target = node;
//        循环的查找左节点，就会找到最小值
        while (target.right != null) {
            target = target.right;
        }
//        这时target就指向最小节点
        delNode(target.value);
        return target.value;
    }


    //    删除节点
    public void delNode(int value) {
        if (root == null) {
            return;
        }
//        需要先去找要删除的节点targetNode
        Node targetNode = search(value);
        if (targetNode == null) {
            return;
        }
//        如果发现当前这颗二叉排序树只有一个节点，
        if (root.left == null && root.right == null) {
            root = null;
            return;
        }

//        去查找targetNode的父节点
        Node parent = searchParent(value);
//        如果要删除的是叶子节点
        if (targetNode.left == null && targetNode.right == null) {
            if (parent.left != null && parent.left.value == value) {
                parent.left = null;
            } else if (parent.right != null && parent.right.value == value) {
                parent.right = null;
            }
            return;
        } else if (targetNode.left != null && targetNode.right != null) {  //删除目录下存在左右子树
            int minValue = delRight(targetNode.right);
            targetNode.value = minValue;
        } else { // 删除只有一颗子树的节点
            // 如果要删除的节点有左子节点
            if (targetNode.left != null) {
                if (parent == null) {
                    root = targetNode.left;
                    return;
                }
                if (parent.left.value == value) {
                    parent.left = targetNode.left;
                } else if (parent.right.value == value) {
                    parent.right = targetNode.left;
                }
            } else {  // 要删除的节点有右子节点
                if (parent == null) {
                    root = targetNode.right;
                    return;
                }
                if (parent.left.value == value) {
                    parent.left = targetNode.right;
                } else if (parent.right.value == value) {
                    parent.right = targetNode.right;
                }
            }
        }

    }

    public void add(int value) {
        if (root != null) {
            root.add(new Node(value));
        } else {
            root = new Node(value);
        }
    }

    public void infixOrder() {
        if (root != null) {
            root.infixOrder();
        } else {
            System.out.println("不能遍历");
        }
    }

}


class Node {
    int value;
    Node left;
    Node right;

    public Node(int value) {
        this.value = value;
    }

    //    返回左子树的高度
    public int leftHeight() {
        if (left == null) {
            return 0;
        }
        return left.height();
    }

    //    返回右子树的高度
    public int rightHeight() {
        if (right == null) {
            return 0;
        }
        return right.height();
    }

    //    返回当前节点的高度,以该节点为根节点的树的高度
    public int height() {
        return Math.max(left == null ? 0 : left.height(), right == null ? 0 : right.height()) + 1;
    }

    private void leftRotate() {
//        创建新的节点，当前根节点的值
        Node newNode = new Node(value);
//        把新的节点左子树设置了当前节点的左子树
        newNode.left = left;
//        把新节点的右子树设置为当前节点的右子树的左子树
        newNode.right = right == null ? null : right.left;
//        把当前节点的值替换为右子节点的值
        value = right == null ? null : right.value;
//        把当前节点的右子树设置成右子树的右子树
        right = right == null ? null : right.right;
//        把当前节点的左子树设置为新节点
        left = newNode;
    }

    //    右旋转
    private void rightRotate() {
        //        创建新的节点，当前根节点的值
        Node newNode = new Node(value);
//        把新的节点的右子树设置为当前节点的右子树
        newNode.right = right;
        newNode.left = left.right;
        value = left.value;
        left = left.left;
        right = newNode;
    }

    /**
     * 查找要删除的节点
     *
     * @param value
     */
    public Node search(int value) {
        if (this.value == value) { // 找到该节点
            return this;
        } else if (this.value > value) {  // 如果查找的值小于当前节点，向左子树递归查找
            if (this.left == null) {
                return null;
            }
            return this.left.search(value);
        } else {
            if (this.right == null) {
                return null;
            }
            return this.right.search(value);
        }
    }

    /**
     * 查找要删除的节点的父节点
     *
     * @param value 要找的节点的值
     * @return 返回的是要删除的节点的父节点，如果没有就返回null;
     */
    public Node searchParent(int value) {
        if (this.value == value) {
            return null;
        }
        if ((this.left != null && this.left.value == value) || (this.right != null && this.right.value == value)) {
            return this;
        } else {
//            如果查找的值小于当前节点的值，并且当前节点的左子节点不为空
            if (value < this.value && this.left != null) {
                return this.left.searchParent(value);
            } else if ((value >= this.value && this.right != null)) {
                return this.right.searchParent(value);
            } else {
                return null;
            }
        }
    }

    public void add(Node node) {
        if (node == null) {
            return;
        }
        if (node.value < value) {
            if (left == null) {
                left = node;
            } else {
                this.left.add(node);
            }
        } else {
            if (right == null) {
                right = node;
            } else {
                this.right.add(node);
            }
        }
        int i = leftHeight();
        int i1 = rightHeight();
//        当添加完一个节点后，如果右子树的高度比左子树的高度大于1，发生左旋转
        if (rightHeight() - leftHeight() > 1) {
            if (right != null && right.leftHeight() > right.rightHeight()) {
                right.rightRotate();
            }
//                先对右子树进行
            leftRotate();
            return;
        }

        if (leftHeight() - rightHeight() > 1) {
            if (left != null && left.rightHeight() > left.leftHeight()) {
//                先对当前节点的左节点，进行左旋转
                left.leftRotate();
            }
//                先对右子树进行
            rightRotate();
        }
    }

    public void infixOrder() {
        if (left != null) {
            left.infixOrder();
        }
        System.out.println(this);
        if (right != null) {
            right.infixOrder();
        }
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }
}
```



# 多路查找树

二叉树和B树

二叉树的问题分析

二又树的操作效率较高，但是也存在问题，请看下面的二叉树

![image-20220121112413726](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220121112413726.png)

1. 二叉树需要加载到内存的，如果二又树的节点少，没有什么问题，但是如果二叉树的节点很多比如1亿），就存在如下问题
2. 问題1：在构建二叉树时，需要多次进行操作海量数据存在数据库或文件中，节点海量，构建-叉树时，速度有影响
3. 问題2：节点海量，也会造成二叉树的高度很大，会降低操作速度

## **多叉树**

1. 在二叉树中，每个节点有数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树（multiway tree
2. 后面我们讲解的23树，2-3-4树就是多又树，多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化
3. 举例说明（下面23树就是一颗多叉树）

![image-20220121112858353](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220121112858353.png)

## B**树的基本介绍**

B树通过重新组织节点，降低树的高度，并且减少i/o读写次数来提升效率。

![image-20220121113146297](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220121113146297.png)

1. 如图B树通过重新组织节点，降低了树的高度
2. 文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页得大小通常为4k），这样每个节点只需要一次/o就可以完全载入
3. 将树的度M设置为1024，在600亿个元素中最多只需要4次I/O操作就可以读取到想要的元素，B树(B+)广泛应用于文件存储系统以及数据库系统中

## **2-3树**

2-3树基本介绍

2-3树是最简单的B-树结构，具有如下特点：

1. 23树的所有叶子节点都在同一层（只要是B树都满足这个条件
2. 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点
3. 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点
4. 2-3树是由二节点和三节点构成的树。

### 代码构建2-3树

将数列{16,24,12,32,14,26,34,10,8,28,38,20}构建成2-3树，并保证数据插入的大小顺序。（示一下构建2-3树的过程丁

![image-20220121114233491](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220121114233491.png)

### 2-3树其它说明

除了2-3树，还有2-3-4树等，概念和2-3树类似，也是一种B树。如图：

![image-20220121122454153](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220121122454153.png)

## B树、B+树和B*树

### B树介绍

B-treel树即B树，B即 Balanced，平衡的意思。有人把B-tre翻译成B-树，容易让人产生误解。会以为B-树是一种树，而B树又是另一种树。实际上，Bree就是指的B树。

前面已经介绍了2-3树和23-4树，他们就是B树（英语：Bte也写成B树），这里我们再做一个说明，我们在学习Mysq时，经常听到说某种类型的索引是基于B树或者B+树的，如图

![image-20220121164601856](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220121164601856.png)

### B+树的介绍

B+树是B树的变体，也是一种多路搜索树。

![image-20220121165011810](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220121165011810.png)

### B * 树的介绍

B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。

![image-20220121165837938](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220121165837938.png)

# 图

## **基本介绍**

图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。结点也可以称为项点。如图：

![image-20220121171619674](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220121171619674.png)

## 图的常用概念

1. 顶点（vertex）
2. 边（edge
3. 路径
4. 无向图（右图）

![image-20220121171826304](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220121171826304.png)

>  无向图：顶点之间的连接没有方向，比如AB即可以是A→>B也可以B-A路径：比如从D->C的路径有
>
> 1）D->B->C
>
> 2）D->A->B->C

5. 有向图
6. 带权图

![image-20220121172133622](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220121172133622.png)

## 图的表示方式

图的表示方式有两种：二维数组表示（邻接矩阵）；链表表示（邻接表）。

邻接矩阵

邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是的row和co表示的是1....n个点。

![image-20220121172315768](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220121172315768.png)

邻接表

1. 邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在会造成空间的一定损失
2. 邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成

![image-20220121172528770](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220121172528770.png)

## 代码实现

![image-20220121173621663](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220121173621663.png)

思路分析：

1. 存储顶点String  使用ArrayList
2. 保存矩阵 使用二维数组  int[][] edges



图遍历

所谓图的遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种访问策略 

1.深度优先遍历

 2.广度优先遍历

## 深度优先遍历基本思想

图的深度优先搜索（Depth First Search）。

1）深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点，可以这样理解：每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。

2）我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。

3）显然，深度优先搜索是一个递归的过程

**深度优先遍历算法步骤**

1）访问初始结点v，并标记结点v为已访问。

2）查找结点v的第一个邻接结点w。

3）若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续。

4）若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123）。

5）查找结点v的w邻接结点的下一个邻接结点，转到步骤3。

![image-20220121180625648](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220121180625648.png)



```java
package com.wudidemiao.study.graph;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * @author wudidemiaoa
 * @date 2022/1/21
 * @apiNote
 */
public class Graph {
    /**
     * 存储顶点集合
     */
    private List<String> vertexList;

    /**
     * 存储图对应的临界举证
     */
    private int[][] edges;

    private boolean[] isVisited;

    /**
     * 表示边的数目
     */
    private int numOfEdges;

    public static void main(String[] args) {
        String[] vertexValue = {"A", "B", "C", "D", "E"};
        Graph graph = new Graph(5);
        for (String s : vertexValue) {
            graph.insertVertex(s);
        }
        graph.insertEdge(0, 1, 1);
        graph.insertEdge(0, 2, 1);
        graph.insertEdge(1, 2, 1);
        graph.insertEdge(1, 3, 1);
        graph.insertEdge(1, 4, 1);
        graph.show();
        graph.dfs();
    }

    public Graph(int n) {
//        初始化矩阵和vertexList
        edges = new int[n][n];
        isVisited = new boolean[n];
        this.vertexList = new ArrayList<>(n);
        this.numOfEdges = 0;
    }

    // 获取第一个邻接节点的下标

    /**
     * @param index
     * @return 如果存在就返回对应的下标
     */
    public int getFirstNeighbor(int index) {
        for (int i = 0; i < vertexList.size(); i++) {
            if (edges[index][i] > 0) {
                return i;
            }
        }
        return -1;
    }

    //    根据前一个邻接节点的下标来获取下一个邻接节点
    public int getNextNeighbor(int v1, int v2) {
        for (int i = v2 + 1; i < vertexList.size(); i++) {
            if (edges[v1][i] > 0) {
                return i;
            }
        }
        return -1;
    }

    //    深度优先遍历suanfa
    public void dfs(boolean[] isVisited, int i) {
//        首先访问该节点
        System.out.print(getValueByIndex(i) + "->");
        isVisited[i] = true;
        int firstNeighbor = getFirstNeighbor(i);
        while (firstNeighbor != -1) {
            if (!isVisited[firstNeighbor]) {
                dfs(isVisited, firstNeighbor);
            }
//            firstNeighbor 被访问过
            firstNeighbor = getNextNeighbor(i, firstNeighbor);
        }
    }

//    对dfs进行重载
    public void dfs(){
//        遍历所有的节点，dfs
        for (int i = 0; i < getNumOfVertex(); i++) {
            if(!isVisited[i]){
                dfs(isVisited,i);
            }
        }
    }

    //    途中常用的方法
    public int getNumOfVertex() {
        return vertexList.size();
    }

    //    途中常用的方法
    public int getNumOfEdges() {
        return numOfEdges;
    }

    //    返回节点i对应数据的下标
    public String getValueByIndex(int i) {
        return vertexList.get(i);
    }

    //    返回v1和v2的权值
    public int getWeight(int v1, int v2) {
        return edges[v1][v2];
    }

    //    显示图对应的举证
    public void show() {
        for (int[] edge : edges) {
            System.out.println(Arrays.toString(edge));
        }

    }


    /**
     * 插入顶点
     *
     * @param vertex
     */
    public void insertVertex(String vertex) {
        vertexList.add(vertex);
    }

    //    添加边

    /**
     * @param v1     表示第几个顶点对应的下标
     * @param v2     第二个顶点对应的下标
     * @param weight
     */
    public void insertEdge(int v1, int v2, int weight) {
        edges[v1][v2] = weight;
        edges[v2][v1] = weight;
        numOfEdges++;
    }
}

```



## 图的广度优先遍历

广度优先遍历基本思想

图的广度优先搜索（Broad First Search）

类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点

广度优先遍历算法步骤
1）访问初始结点v并标记结点v为已访问
2）结点v入队列
3）当队列非空时，继续执行，否则算法结束。
4）出队列，取得队头结点u。
5）查找结点u的第一个邻接结点w。
6）若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤
6.1若结点w尚未被访问，则访问结点w并标记为已访问。
6.2结点w入队列
6.3查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。

举例

![image-20220121191054053](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220121191054053.png)

代码

```java
//    对一个节点进行广度优先遍历的方法
    public void bfs(boolean[] isVisited,int i){
        int u;  // 表示队列头节点对应的下标
        int w;  // 表示队邻接节点的下标
//        队列，节点访问顺序
        LinkedList<Integer> linkedList = new LinkedList();
        // 访问节点 输出节点信息
        System.out.println(getValueByIndex(i)+"=>");
        isVisited[i] = true;
//        将这个节点加入队列
        linkedList.addLast(i);
        while (!linkedList.isEmpty()){
//            取出队列的头下表
            u = linkedList.removeFirst();
            w = getFirstNeighbor(u);
            while (w!=-1){
//                是否访问过
                if(!isVisited[w]){
                    // 访问节点 输出节点信息
                    System.out.println(getValueByIndex(w)+"=>");
//                    标记已经访问
                    isVisited[w]=true;
//                    入对
                    linkedList.addLast(w);
                }

//                以u为前驱节点找w后面的第一个节点
                w = getNextNeighbor(u,w);  // 体现出广度优先
            }

        }
    }

//    遍历所有的节点搜进行广度优先搜索
    public void bfs(){
        for (int i = 0; i < getNumOfVertex(); i++) {
            if(!isVisited[i]){
                bfs(isVisited,i);
            }
        }
    }
```

# 常用的十种算法

## 二分查找算法（非递归）

二分查找算法（非递归）介绍

1）前面我们讲过了二分查找算法，是使用递归的方式，下面我们讲解二分查找算法的非递归方式

2）二分查找法只适用于从有序的数列中进行查找（比如数字和字母等），将数列排序后再进行查找

3）二分查找法的运行时间为对数时间o（bgn），即查找到需要的目标位置最多只需要log2 n步，假设从[0，99]的队列（100个数，即n=100）中寻到目标数30，则需要查找步数为如log2 100，即最多需要查找7次（2^6<100<2^7）

二分查找算法（非递归）代码实现

数组{1，3，8，10，1167，10}，编程实现二分查找，要求使用非递归的方式完成

思路分析：

代码实现：

```java
package com.wudidemiao.study.algorithm.binarysearchnorecursion;

/**
 * @author wudidemiaoa
 * @date 2022/1/22
 * @apiNote
 */
public class BinarySearchNoRecur {
    public static void main(String[] args) {
        int[] arr = {1, 3, 8, 10, 12, 14};
        System.out.println(binarySearch(arr, 14));
    }

    /**
     * 二分查找的非递归实现
     *
     * @param arr    带查找的数组
     * @param target 需要查找的数
     * @return 返回对应的下标，-1表示没有找到
     */
    public static int binarySearch(int arr[], int target) {
        int left = 0;
        int right = arr.length - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] > target) {  // 需要向左边1查找
                right = mid - 1;
            } else {
                left = mid + 1;  // 需要向右边查找
            }
        }

        return -1;
    }
}
```

## 分治算法

分治算法介绍

1. 分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题…直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法（快速排序，归并排序），傅立叶变换（快速傅立叶变换）
2. 分治算法可以求解的一些经典问题
   - 二分搜索
   - 大整数乘法
   - 棋盘覆盖合并排序快速排序
   - 线性时间选择
   - 最接近点对问题
   - 循环赛日程表
   - 汉诺塔

分治算法的基本步骤

分治法在每一层递归上都有三个步骤：

1）分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题

2）解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题

3）合并：将各个子问题的解合并为原问题的解。

分治（Divide-and-Conquer（P）算法设计模式如下：

![image-20220122114518939](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220122114518939.png)

其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC（P是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过nO时直接用算法 ADHOC（P）求解。算法MERGE1，y2…，yk）是该分治法中的合并子算法，用于将P的子问题P1，P2…，P的相应的解y1y2，…yk合并为P的解。

分治算法最佳实践汉诺塔

>汉诺塔的传说
>
>汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。
>
>假如每秒钟一次，共需多长时间呢？移完这些金片需要584554亿年以上，太阳系的预期寿命据说也就是数百亿年。真的过了584554亿年，地球上的一切生命连同梵塔、庙宇等，都早已经灰飞烟灭。

分治算法最佳实践汉诺塔

思路分析

	1. 如果只有一个盘  a-c
 	2. 如果我们n>=2 情况，我们总是可以看作是两个盘，1个是最下面的盘，和上面所有盘
 	3. 先把最上面的盘a->b
 	4. 把最下边的盘a->c
 	5. 把B塔的所有盘移动到b->c

代码：

```java
package com.wudidemiao.study.algorithm.dac;

/**
 * @author wudidemiaoa
 * @date 2022/1/22
 * @apiNote
 */
public class Hanitower {
    public static void main(String[] args) {
        hanoitTower(5,'A','B','c');
    }

    //    汉罗塔移动方案
//    使用分治算法
    public static void hanoitTower(int num, char a, char b, char c) {
//         如果只有一个盘
        if (num == 1) {
            System.out.println("第一个盘从" + a + "->" + c);
        } else {
//            1. 如果我们n>=2 情况，我们总是可以看作是两个盘，1个是最下面的盘，和上面所有盘
//            2. 先把最上面的盘a->b
            hanoitTower(num - 1, a, c, b);
//           把最下面的盘从a-c
            System.out.println("第" + num + "盘" + a + "->" + c);
//            把B塔的所有盘移动到b->c,移动过程使用到A塔
            hanoitTower(num - 1, b, a, c);
        }
    }
}
```

## 动态规划

应用场景背包问题

背包问题：有一个背包，容量为4磅，现有如下物品

![image-20220122122329652](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220122122329652.png)

1）要求达到的目标为装入的背包的总价值最大，并且重量不超出

2）要求装入的物品不能重复

动态规划算法

动态规划算法介绍

1）动态规划（Dynamic Programming）算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法

2）动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解

3）与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）

4）动态规划可以通过填表的方式来逐步推进，得到最优解

动态规划算法最佳实践背包问题

3）思路分析和图解

- 背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分01背包和完全背包（完全背包指的是：每种物品都有无限件可用）
- 这里的问题属于01背包，即每个物品最多放一个。而无限背包可以转化为01背包。

![image-20220122130612142](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220122130612142.png)

代码演示：

```java
package com.wudidemiao.study.algorithm.dynamic;

/**
 * @author wudidemiaoa
 * @date 2022/1/22
 * @apiNote
 */
public class KnapsackProblem {
    public static void main(String[] args) {
//        物品的重量
        int[] v = {1, 4, 3};
//        物品的价值
        int[] p = {1500, 3000, 2000};
//        动态规划数组
        int m = 4;  // 背包的容量
        int n = v.length;  // 物品的个数
//        dp[i][j]得含义 表示在前i个物品中能够装入容量为j得背包中得最大价值
        int[][] dp = new int[n + 1][m + 1];

//        初始化第一行和第一列
        for (int i = 0; i < dp.length; i++) {
            dp[i][0] = 0;
        }
        for (int i = 0; i < dp[0].length; i++) {
            dp[0][i] = 0;
        }

        for (int i = 1; i < dp.length; i++) {
            for (int j = 1; j < dp[0].length; j++) {
                if (v[i - 1] > j) {
                    dp[i][j] = dp[i - 1][j];
                }
                if (j >= v[i - 1]) {
                    dp[i][j] = Math.max(dp[i - 1][j], p[i - 1] + dp[i - 1][j - v[i - 1]]);
                }
            }
        }

        System.out.println(dp[3][3]);
    }
}
```

## KMP算法

应用场景字符串匹配问题

字符串匹配问题：

1）有一个字符串str1=""硅硅谷尚硅谷你尚硅尚硅谷你尚硅谷你尚硅你好"，和个子串st2=尚硅谷你尚硅你"

2）现在要判断str1是否含有str2，如果存在，就返回第一次出现的位置，如果没有，则返回-1

暴力匹配算法

如果用暴力匹配的思路，并假设现在st1匹配到i位置，子串2匹配到j位置，则有

1）如果当前字符匹配成功（即stri=st2]），则i++，j+，继续匹配下一个字符

2）如果失配（即str1[l！=st2]），令i=i-（j-1），j=0。相当于每次匹配失败时，i回溯，j被置为0。

3）用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间。（不可行！

4）暴力匹配算法实现

KMP算法介绍

1）KMP是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法

2）Knuth-Morris-Pratt字符串查找算法，简称为“KMP算法”，常用于在一个文本串S内查找一个模式串P的出现位置，这个算法由 Donald Knuth、Vaughan Pratt，James h.Morris三人于1977年联合发表，故取这3人的姓氏命名此算法3）KMP方法算法就利用之前判断过信息，通过一个next数组，保存模式丰中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间

4）参考资料：https://www.cnblogs.com/ZuoAndFuturegirl/p/9028287.html

举例来说，有一个字符串St1=“BBC ABCDAB ABCDABCDABDE”，判断，里面是否包含另一个字符串Str2=“ABCDABD”？
1首先，用Str1的第一个字符和Str的第一个字符去比较，不符合，关键词向后移动一位

![image-20220122163230217](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220122163230217.png)

2.重复第一步，还是不符合，再后移

![image-20220122163250060](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220122163250060.png)

3.一直重复，直到Str1有一个字符与St2的第一个字符符合为止

![image-20220122163453100](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220122163453100.png)

4.接着比较字符串和搜索词的下一个字符，还是符合。

![image-20220122163504773](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220122163504773.png)

5.遇到St1有一个字符与St2对应的字符不符合。

![image-20220122163517144](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220122163517144.png)

6.这时候，想到的是继续遍历St的下一个字符，重复第1步。（其实是很不明智的，因为此时BCD已经比较过了，没有必要再做重复的工作，一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。）

![image-20220122163541474](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220122163541474.png)

7怎么做到把刚刚重复的步骤省略掉？可以对Str2计算出一张《部分匹配表》，这张表的产生在后面介绍

![image-20220122164053076](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220122164053076.png)

8.已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数

移动位数=已匹配的字符数-对应的部分匹配值

因为6-2等于4，所以将搜索词向后移动4位。

9.因为空格与C不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数=2-0，结果为2，于是将搜索词向后移2位。

![image-20220122164616374](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220122164616374.png)

10.因为空格与A不匹配，继续后穊位。

![image-20220122164923990](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220122164923990.png)

11.逐位比较，直到发现C与D不匹配。于是，移动位数=6-2，继续将搜索词向后移动4位。

![image-20220122165135383](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220122165135383.png)

12逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数=7-0，再将搜索词向后移动7位，这里就不再重复了。

![image-20220122165207478](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220122165207478.png)

13介绍《部分匹配表》怎么产生的先介绍前缀，后缀是什么

![image-20220122165336080](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220122165336080.png)

部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例

”A”的前缀和后缀都为空集，共有元素的长度为0

”AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；

”ABC”的前缀为AAB]，后缀为BqC，共有元素的长度0

”ABCD”的前缀为A，AB，ABC，后缀为[BCD.CD，D]，共有元素的长度为0

”ABCDA”的前缀为[AAB，ABC，ABCD]，后缀为 BCDA CDA.DA.A]，共有元素为”A”，长度为1

”ABCDAB”的前缀为[AAB，ABC，ABCD，ABCDA]，后缀为[BCDAB，CDAB，DAB，AB，B]，共有元素为”AB”，长度为2；ABCDABD”的前缀为[AAB，ABC，ABCD，ABCDA.ABCDAB]，后缀为[BCDABD.CDABD，DABD，ABD，BDD共有元素的长度为0。

14.”部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4位

（字符串长度部分匹配值），就可以来到第二个”AB”的位置

![image-20220122165840644](https://raw.githubusercontent.com/xgdwudi/images/master/img/image-20220122165840644.png)

到此KMP算法思想分析完毕！



代码实现：

```java
package com.wudidemiao.study.algorithm.kmp;

/**
 * @author wudidemiaoa
 * @date 2022/1/22
 * @apiNote
 */
public class KMPALgorithm {
    public static void main(String[] args) {
        String str = "BBC ABCDAB ABCDABCDABDE";
        String str2 = "ABCDABD";
        int[] ints = kmpNext(str2);
        System.out.println(kmpSearch(str, str2, ints));
    }


    /**
     * kmp搜索
     *
     * @param str1 源字符串
     * @param str2 子串
     * @param next 部分匹配表
     * @return 返回下标
     */
    public static int kmpSearch(String str1, String str2, int[] next) {
//        遍历
        for (int i = 0, j = 0; i < str1.length(); i++) {
            if (j > 0 && str1.charAt(i) != str2.charAt(j)) {
                j = next[j - 1];
            }
            if (str1.charAt(i) == str2.charAt(j)) {
                j++;
            }

            if (j == str2.length()) {  // 找到了
                return i - j + 1;
            }
        }
        return -1;
    }

    //        获取到一个字符串（子串）的部分匹配值表
    public static int[] kmpNext(String dest) {
//        创建一个数组，保存部分匹配值
        int[] next = new int[dest.length()];
        next[0] = 0;
        for (int i = 1, j = 0; i < dest.length(); i++) {
//            当dest.charAt(i) != dest.chartAt(j) 我们需要从next[j-1] 获取新的j
//            知道我们发现 有dest.charAt(i) == dest.charAt(j) 成立才退出
//            这是kmp算法的核心点
            while (j > 0 && dest.charAt(i) != dest.charAt(j)) {
                j = next[j - 1];
            }
//            当满足时，部分匹配值就是+1
            if (dest.charAt(i) == dest.charAt(j)) {
                j++;
            }
            next[i] = j;
        }
        return next;
    }
}
```

算法暂看到这，后面再挑时间吧！！P163

