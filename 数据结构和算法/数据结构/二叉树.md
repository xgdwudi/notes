```
title: 数据结构和算法
date: 2022/01/20 20:33:25  
tags:
- 数据结构
- 算法
- java
- 二叉树
categories: 数据结构和算法
thumbnail: https://tse1-mm.cn.bing.net/th/id/R-C.680beccb8a73a1599965c5f1ee78de45?rik=ktSYW8q%2bHNQ%2fDQ&riu=http%3a%2f%2fhdfs.hdmool.com%2fhdfs3%2fM00%2f00%2f08%2fwKgADVycfdOAZmpRAAEVbyEMsYs676.jpg&ehk=amHevLJvpo1vNq5ywCLdwMXgA30XM1L0M5klygNCOr8%3d&risl=&pid=ImgRaw&r=0
cover: https://tse1-mm.cn.bing.net/th/id/R-C.680beccb8a73a1599965c5f1ee78de45?rik=ktSYW8q%2bHNQ%2fDQ&riu=http%3a%2f%2fhdfs.hdmool.com%2fhdfs3%2fM00%2f00%2f08%2fwKgADVycfdOAZmpRAAEVbyEMsYs676.jpg&ehk=amHevLJvpo1vNq5ywCLdwMXgA30XM1L0M5klygNCOr8%3d&risl=&pid=ImgRaw&r=0
```

# 数据结构-（哈希表）

## 哈希表基本介绍

<!-- more -->

散列表（Hash table，也叫哈希表），是根据关键码值（Key value）而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。

结构：

![image-20220117120402950](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220117120402950.png)



**哈希表实现**：

​	数组+链表

​	数组+二叉树

分析

![image-20220117122742359](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220117122742359.png)

哈希表自实现

```java
package com.wudidemiao.study.hash;

/**
 * @author wudidemiaoa
 * @date 2022/1/17
 * @apiNote
 */
public class SinceTheImplHash {
    public static void main(String[] args) {
        HashTableImpl hashTable = new HashTableImpl(5);
        hashTable.add(new Emp(1, "张三"));
        hashTable.add(new Emp(2, "李四"));
        hashTable.add(new Emp(3, "王五"));
        hashTable.add(new Emp(6, "炸弹"));
        hashTable.list();
        hashTable.getById(4);
        hashTable.removeByid(6);
        hashTable.removeByid(1);
        hashTable.removeByid(1);
        hashTable.list();
    }
}

class HashTableImpl {
    private EmplinkedList[] emplinkedLists;

    private int size;

    public HashTableImpl(int size) {
        this.size = size;
        ;
        this.emplinkedLists = new EmplinkedList[size];
        for (int i = 0; i < size; i++) {
            this.emplinkedLists[i] = new EmplinkedList();
        }
    }

    public void add(Emp emp) {
//        根据 员工的id，得到员工应该添加到那条链表
        int hash = hash(emp.id);
        emplinkedLists[hash].add(emp);
    }

    public void list() {
        for (int index = 0; index < emplinkedLists.length; index++) {
            emplinkedLists[index].list(index);
        }
    }

    public void getById(int id) {
        int hash = hash(id);
        Emp byId = emplinkedLists[hash].getById(id);
        if (byId == null) {
            System.out.println("没有找到");
        } else {
            System.out.println("找到了" + byId);
        }
    }
    public void removeByid(int id) {
        int hash = hash(id);
        Emp byId = emplinkedLists[hash].removeById(id);
        if (byId == null) {
            System.out.println("没有找到");
        } else {
            System.out.println("找到了" + byId);
        }
    }

    public int hash(int id) {
        return id % size;
    }
}

// 链表
class EmplinkedList {
    private Emp head;  // 头指针，指向当前链表的第一个雇员

    //    添加雇员，id是自增长的
    public void add(Emp emp) {
        if (head == null) {
            head = emp;
            return;
        }
//        如不是第一个，添加辅助指针，到最后一个
        Emp curEmp = head;
        while (true) {
            if (curEmp.next == null) {
                break;
            }

            curEmp = curEmp.next;  // 后移
        }
        curEmp.next = emp;
    }

    public void list(int index) {
        System.out.println();
        if (head == null) {
            System.out.println("第" + index + "条链表为空,编号：");
            return;
        }
        System.out.println("第" + index + "条链表信息为：");
        Emp curEmp = head; //辅助指针
        while (true) {
            System.out.printf("第" + index + "条 =>id=%d链表 name=%s\t", curEmp.id, curEmp.name);
            if (curEmp.next == null) {
                break;
            }
            curEmp = curEmp.next;  // 后移
        }
    }

    public Emp removeById(int id){
        if (head == null) {
            System.out.println("链表为空");
            return null;
        }
        Emp curEmp = head; //辅助指针
        Emp prep = curEmp;
        while (true) {
            if (curEmp == null) {
                break;
            }
            if (curEmp.id == id) {
                if(prep == curEmp){
                    head = curEmp.next;
                }else {
                    prep.next = curEmp.next;
                }
                curEmp.next = null;
                break;
            }
            prep = curEmp;
            curEmp = curEmp.next;  // 后移
        }
        return curEmp;
    }

    public Emp getById(int id) {
        if (head == null) {
            System.out.println("链表为空");
            return null;
        }
        Emp curEmp = head; //辅助指针
        while (true) {
            if (curEmp.id == id) {
                break;
            }
            curEmp = curEmp.next;  // 后移
            if (curEmp == null) {
                break;
            }
        }
        return curEmp;
    }
}

// 表示一个雇员
class Emp {
    public int id;

    public String name;

    public Emp next; // next默认为null

    public Emp(int id, String name) {
        this.id = id;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Emp{" +
                "id=" + id +
                ", name='" + name;
    }
}

```

# 数据结构-> 树结构基础算法

## 树

**为什么需要树这种数据结构**

1. 数组存储方式的分析
   优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。
   缺点：如果要检索具体某个值，或者插入值（按一定顺序）会整体移动，效率较低[际意图]
2. 链式存储方式的分析
   优点：在一定程度上对数组存储方式有优化（比如：插入一个数值节点，只需要将插入节点，链接到链表中即可，删除效率也很好）。
   缺点：在进行检索时，效率仍然较低，比如（检索某个值，需要从头节点开始遍历）
3. 树存储方式的分析又删家&
   能提高数据存储，读取的效率，比如利用二叉排序树（Binary Sort Tree），既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。

**二叉排序树结构图**

【7，3，10，1，5，9，12】

![image-20220117142613405](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220117142613405.png)

分析一把以二叉排序树来存储数据的效率

（1）查找12，经过两次比较就找到12结点

（2）添加13，很快

（3）删除1结点

## 常用术语

![image-20220117143403041](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220117143403041.png)

树的常用术语（结合示意图理解）：

1. 节点
2. 根节点  (A)
3. 父节点 
4. 子节点
5. 叶子节点（没有子节点的节点）
6. 节点的权（节点值）
7. 路径（从root节点找到该节点的路线）
8. 层
9. 子树
10. 树的高度（最大层数）
11. 森林：多颗子树构成森林

## **二叉树的概念**

1. 树有很多种，每个节点最多只能有两个子节点的一种形式称为二又树。
2. 二叉树的子节点分为左节点和右节点。
3. ![image-20220117171258659](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220117171258659.png)
4. 如果该二叉树的所有叶子节点都在最后一层，并且结点总数=2An-1，n为层数，则我们称为满二叉树。
5. 如果该二又树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树。
6. ![image-20220117171752150](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220117171752150.png)

二叉树的前序、中序、后序遍历

前序遍历：先输出父节点，再遍历左子树和右子树

中序遍历：先遍历左子树，再输出父节点，再遍历右子树

后序遍历：先遍历左子树，再遍历右子树，最后输出父节点

**小结：看输出父节点的顺序，就确定是前序，中序还是后序**

遍历分析：

1. 创建一颗二叉树
2. 如果是前序遍历，
   1. 先输出当前节点，（初始的时候是root节点）
   2. 如果左子节点不为空，则递归前序遍历，
   3. 如果右子节点不为空，则递归继续前序遍历
3. 中序遍历
   1. 如果当前节点左子节点不为空，则递归中序遍历
   2. 输出当前节点，
   3. 如果当前节点的右子节点不为空，则递归中序遍历
4. 后序遍历
   1. 如果当前节点的左子节点不为空，则递归后序遍历
   2. 如果当前节点的右子节点不为空，则递归后序遍历
   3. 输出当前节点

代码实现

```java
// 创建节点
class HeroNode {
    private int id;
    private String name;
    //    左右默认为空
    private HeroNode left;
    private HeroNode right;

    public HeroNode(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "id=" + id +
                ", name=" + name +
                '}';
    }

    //     前序遍历
    public void preOrder() {
        System.out.println(this);  // 先输出父节点
//        递归左子树前序遍历
        if (this.left != null) {
            this.left.preOrder();
        }
        if (this.right != null) {
            this.right.preOrder();
        }
    }

    //    中序遍历
    public void inFixOrder() {
//        递归左子树前序遍历
        if (this.left != null) {
            this.left.inFixOrder();
        }
        System.out.println(this);  // 输出父节点
        if (this.right != null) {
            this.right.inFixOrder();
        }
    }

    //    后序遍历
    public void afterOrder() {
        //        递归左子树前序遍历
        if (this.left != null) {
            this.left.afterOrder();
        }
        if (this.right != null) {
            this.right.afterOrder();
        }
        System.out.println(this);  // 输出父节点
    }
}

```

## 二叉树的查找指定节点

思路分析：

使用前序、中序、后序查找指定的节点

前序查找的思路

> 1. 先判断当前节点的no是都等于查找的
> 2. 如果是相等，则返回当前节点
> 3. 如果不等，则判断当前的左子节点是否为空，部位空，则递归前序查找
> 4. 如果左递归前序查找，找到节点，则返回，否继续判断，当前的节点的右子节点是否为空，如果不空，则继续向右递归前序查找

中序查找的思路

> 1. 先判断当前节点的左子节点是否为空，不为空，则递归中序查找，找到则返回
> 2. 如找不到，则判断当前节点的no是都等于查找的，
> 3. 如果是相等，则返回当前节点
> 4. 如找不到，则继续判断当前的节点的右子节点是否为空，如果不空，则继续向右递归中序查找

后序查找的思路

>1. 先判断当前节点的左子节点是否为空，不为空，则递归后序查找，找到则返回
>2. 继续判断当前的节点的右子节点是否为空，如果不空，则继续向右递归后序查找
>3. 如找不到，则判断当前节点的no是都等于查找的，
>4. 如果是相等，则返回当前节点

代码

```java

    //    前序查找
    public HeroNode preOrderSearch(int id) {
        System.out.println("进入前序遍历");
        if (this.id == id) {
            return this;
        }
        HeroNode node = null;
        if (this.left != null) {
            node = this.left.preOrderSearch(id);

        }
        if (node != null) {
            return node;
        }

        if (this.right != null) {
            node = this.right.preOrderSearch(id);
        }
        return node;
    }


    //   中序查找
    public HeroNode infixSearch(int id) {
        HeroNode node = null;
        if (this.left != null) {
            node = this.left.infixSearch(id);
        }
        if (node != null) {
            return node;
        }
        System.out.println("进入中序查找");
        if (this.id == id) {
            return this;
        }

        if (this.right != null) {
            node = this.right.infixSearch(id);
        }
        return node;
    }

    //     后序查找
    public HeroNode postSearch(int id) {
        HeroNode node = null;
        if (this.left != null) {
            node = this.left.postSearch(id);
        }
        if (node != null) {
            return node;
        }

        if (this.right != null) {
            node = this.right.postSearch(id);
        }
        if (node != null) {
            return node;
        }
        System.out.println("进入后序查找");
        if (this.id == id) {
            return this;
        }

        return null;
    }
```

## 二叉树删除节点

二叉树-删除节点
**要求**

1. 如果删除的节点是叶子节点，则删除该节点
2. 如果删除的节点是非叶子节点，则删除该子树.
3. 测试，删除掉5号叶子节点和3号子树.

**思路分析**

1. 因为二叉树是单向的，所以是判断当前节点的子节点是否需要删除，而不能判断当前的节点是否需要删除，
2. 如果当前节点的左子节点不为空，并且左子节点就是要删除的节点，就将this.left == null;（结束删除任务）
3. 如果当前节点的右子节点不为空，并且右子节点就是要删除的节点，就将this.right== null;（结束删除任务）
4. 如第二步和第三步没有删除节点，那么我们就需要向左子树进行递归删除
5. 如第四步没有删除节点，那么我们就需要向右子树进行递归删除
6. 考虑如果树是空树root，如果只有一个root结点，则等价将二叉树置空。

代码实现

```
   public boolean remove(int id) {
        if (this.left != null) {
            if (this.left.id == id) {
                this.left = null;
                return true;
            }
        }

        if (this.right != null) {
            if (this.right.id == id) {
                this.right = null;
                return true;
            }
        }

        return  (this.left !=null&&this.left.remove(id)) || (this.right !=null && this.right.remove(id));
    }
```

## 顺序存储二叉树

顺序存储二叉树的概念

基本说明：

从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组，看下面的示意图。

![image-20220117193926194](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220117193926194.png)

要求：

1. 右图的二叉树的结点，要求以数组的方式来存放arr[1，2，3，4，5，6，6]
2. 要求在遍历数组arr时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成结点的遍历

顺序存储二叉树的特点：

1. 顺序二叉树通常只考虑完全二叉树
2. 第n个元素的左子节点为2*n+1
3. 第n个元素的右子节点为2*n+21
4. 第n个元素的父节点为（n-1）/2
5. n：表示二叉树中的第几个元素（按0开始编号 如上图所示）

代码

```
package com.wudidemiao.study.tree;

/**
 * @author wudidemiaoa
 * @date 2022/1/17
 * @apiNote
 */
public class ArrBinaryTreeDemo {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6, 7};
        ArrBinaryTree arrBinaryTree = new ArrBinaryTree(arr);
        arrBinaryTree.preOrder();
    }
}

class ArrBinaryTree {
    private int[] arr;

    public ArrBinaryTree(int[] arr) {
        this.arr = arr;
    }

    public void preOrder(){
        preOrder(0);
    }

    //    编写方法，完成顺序存储二叉树的前序遍历
    public void preOrder(int order) {
        if (arr == null && arr.length == 0) {
            System.out.println("数组为空，不能按照二叉树的前序遍历。");
        }
        System.out.println(arr[order]);
//        向左前序遍历
        if (order * 2 + 1 < arr.length) {
            preOrder(order * 2 + 1);
        }

//        向右递归遍历
        if (order * 2 + 2 < arr.length) {
            preOrder(order * 2 + 2);
        }
    }
}

```

**八大排序算法中的堆排序，就会使用到顺序存储二叉树**



## 线索化二叉树

将数列{1，3，6，8，10，14}构建成一颗二又树.

![image-20220118113956829](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220118113956829.png)

问题分析：
1）当我们对上面的二叉树进行中序遍历时，数列为（8，3，10，1，6，14}
2）但是6，8，10，14这几个节点的左右指针，并没有完全的利用上。
3）如果我们希望充分的利用各个节点的左右指针，让各个节点可以指向自己的前后节点怎么办？
4）解决方案-线索二叉树

### 基本介绍

线索二叉树基本介绍

1. n个结点的二叉链表中含有n+1公式 2n-（n-1）=n+1 个空指针域。利用二又链表中的空指针域，存放指向结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为“线索"）
2. 这种加上了线索的二又链表称为线索链表，相应的二又树称为线索二叉树（Threaded BinaryTree）。根据线索性质的不同，线索二叉树可分为**前序线索二叉树、中序线索二叉树和后序线索二叉树**三种
3. 一个结点的前一个结点，称为前驱结点
4. 一个结点的后一个结点，称为后继结点

### 思路步奏

线索二叉树应用案例

应用案例说明：将下面的二又树，进行中序线索二叉树。中序遍历的数列为{8，3，10，1，14，6}

![image-20220118122617382](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220118122617382.png)

**说明：当线索化二叉树后，Node节点的属性left和right，有如下情况：**

1. left指回的是左子树，也可能是指向的前驱节点，比如①节点left指向的左子树，而①节点的left指间的就是前驱点.
2. right指向的是右子树，也可能是指向后继节点，比如①节点right指向的是右子树，而⑥节点的right指向的是后继节点.

代码和遍历是一起的

### 线索化二叉树的遍历

说明：对前面的中序线索化的二叉树，进行遍历

分析：因为线索化后，各个结点指向有变化，因此原来的遍历方式不能使用，这时需要使用新的方式遍历线索化二叉树，各个节点可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率。**遍历的次序应当和中序遍历保持一致。**

代码

```java
package com.wudidemiao.study.tree.threadedbinarytree;

/**
 * @author wudidemiaoa
 * @date 2022/1/18
 * @apiNote
 */
public class ThreadedBinaryTreeDemo {
    public static void main(String[] args) {
//        测试中序线索化二叉树功能
        HeroNode root = new HeroNode(1, "tom");
        HeroNode node2 = new HeroNode(3, "jack");
        HeroNode node3 = new HeroNode(6, "tom");
        HeroNode node4 = new HeroNode(8, "tom");
        HeroNode node5 = new HeroNode(10, "tom");
        HeroNode node6 = new HeroNode(14, "tom");

//        二叉树，手动创建
        root.setLeft(node2);
        node2.setLeft(node4);
        node2.setRight(node5);
        root.setRight(node3);
        node3.setLeft(node6);

        BinaryTree binaryTree = new BinaryTree();
        binaryTree.setHead(root);
        binaryTree.threadedNodes(root);
        System.out.println();

//        当线索化二叉树后，不能在使用原来的遍历方法，
        binaryTree.threadedList();
    }
}


// 定义一个ThreadBinaryTree 实现了线索化功能的二叉树
class BinaryTree {
    private HeroNode root;
    //    为了实现线索化，需要创建一个指向当前节点的前驱节点的引用
//    pre 总是保留保留前一个节点
    private HeroNode pre = null;

    public void setHead(HeroNode root) {
        this.root = root;
    }

    /**
     * 遍历中序线索化的二叉树
     */
    public void threadedList() {
//        定义一个变量，存储当前遍历的节点
        HeroNode node = root;
        while (node != null) {
//            循环的找到leftType=1的节点
//            后面随着遍历而变化，因为当leftType==1时，说明改节点时按照线索化处理后的有效节点，
            while (node.getLeftType() == 0) {
                node = node.getLeft();
            }
//           打印当前节点
            System.out.println(node);
//            如果当前节点的右指针指向的是后置节点
            while (node.getRightType() == 1) {
                node = node.getRight();
                System.out.println(node);
            }
//            替换这个遍历的节点
            node = node.getRight();
        }
    }

    /**
     * 编写对二叉树中序线索化的方法
     *
     * @param node 当前需要线索化的节点
     */
    public void threadedNodes(HeroNode node) {
        if (node == null) {
            return;
        }
//        先线索化左子树
        if (node.getLeft() != null) {
            threadedNodes(node.getLeft());
        }
//        在线索化处理当前节点

//        处理当前结点的前驱节点
        if (node.getLeft() == null) {
//          让当前节点的左执政指向前驱节点
            node.setLeft(pre);
//            修改当前做执政的类型,指向前驱节点
            node.setLeftType(1);
        }

        //        处理当前结点的后驱节点
        if (pre != null && pre.getRight() == null) {
//          让当前节点的左执政指向前驱节点
            pre.setRight(node);
//            修改前驱节点的右执政类型
            pre.setRightType(1);
        }
//        每处理一个节点后，让当前节点是下一个节点的前驱节点
        pre = node;

//        让前驱节点的右指针指向当前的节点

//        在线索化处理右子树
        threadedNodes(node.getRight());
    }

    //    前序遍历
    public void preOrder() {
        if (root != null) {
            root.preOrder();
        } else {
            System.out.println("二叉树为空，无法遍历");
        }
    }

    //    中序遍历
    public void infixOrder() {
        if (root != null) {
            root.inFixOrder();
        } else {
            System.out.println("二叉树为空，无法遍历");
        }
    }

    //    hou序遍历
    public void postOrder() {
        if (root != null) {
            root.afterOrder();
        } else {
            System.out.println("二叉树为空，无法遍历");
        }
    }

    //    前序查找
    public HeroNode preOrderSearch(int no) {
        if (root != null) {
            return root.preOrderSearch(no);
        } else {
            return null;
        }
    }

    //    zhong序查找
    public HeroNode infixOrderSearch(int no) {
        if (root != null) {
            return root.infixSearch(no);
        } else {
            return null;
        }
    }

    //    后序
    public HeroNode ipostOrderSearch(int no) {
        if (root != null) {
            return root.postSearch(no);
        } else {
            return null;
        }
    }

    public void remove(int no) {
        if (root.getId() == no) {
            root = null;
            System.out.println("删除成功");
        } else {
            if (root.remove(no)) {
                System.out.println("删除成功");
            } else {
                System.out.println("删除失败");
            }
        }
    }
}


// 创建节点
class HeroNode {
    private int id;
    private String name;
    //    左右默认为空
    private HeroNode left;
    private HeroNode right;
    //    1.弱国leftType == 0，表示指向的是左子树，如果是1则表示前驱结点
//    2.如果rightType == 0，表示指向是右子树，如果是1表示指向后续结点
    private int leftType;

    public int getLeftType() {
        return leftType;
    }

    public void setLeftType(int leftType) {
        this.leftType = leftType;
    }

    public int getRightType() {
        return rightType;
    }

    public void setRightType(int rightType) {
        this.rightType = rightType;
    }

    private int rightType;


    public HeroNode(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "id=" + id +
                ", name=" + name +
                '}';
    }

    //     前序遍历
    public void preOrder() {
        System.out.println(this);  // 先输出父节点
//        递归左子树前序遍历
        if (this.left != null) {
            this.left.preOrder();
        }
        if (this.right != null) {
            this.right.preOrder();
        }
    }

    //    中序遍历
    public void inFixOrder() {
//        递归左子树前序遍历
        if (this.left != null) {
            this.left.inFixOrder();
        }
        System.out.println(this);  // 输出父节点
        if (this.right != null) {
            this.right.inFixOrder();
        }
    }

    //    后序遍历
    public void afterOrder() {
        //        递归左子树前序遍历
        if (this.left != null) {
            this.left.afterOrder();
        }
        if (this.right != null) {
            this.right.afterOrder();
        }
        System.out.println(this);  // 输出父节点
    }

    //    前序查找
    public HeroNode preOrderSearch(int id) {
        System.out.println("进入前序遍历");
        if (this.id == id) {
            return this;
        }
        HeroNode node = null;
        if (this.left != null) {
            node = this.left.preOrderSearch(id);

        }
        if (node != null) {
            return node;
        }

        if (this.right != null) {
            node = this.right.preOrderSearch(id);
        }
        return node;
    }


    //   中序查找
    public HeroNode infixSearch(int id) {
        HeroNode node = null;
        if (this.left != null) {
            node = this.left.infixSearch(id);
        }
        if (node != null) {
            return node;
        }
        System.out.println("进入中序查找");
        if (this.id == id) {
            return this;
        }

        if (this.right != null) {
            node = this.right.infixSearch(id);
        }
        return node;
    }

    //     后序查找
    public HeroNode postSearch(int id) {
        HeroNode node = null;
        if (this.left != null) {
            node = this.left.postSearch(id);
        }
        if (node != null) {
            return node;
        }

        if (this.right != null) {
            node = this.right.postSearch(id);
        }
        if (node != null) {
            return node;
        }
        System.out.println("进入后序查找");
        if (this.id == id) {
            return this;
        }

        return null;
    }

    public boolean remove(int id) {
        if (this.left != null) {
            if (this.left.id == id) {
                this.left = null;
                return true;
            }
        }

        if (this.right != null) {
            if (this.right.id == id) {
                this.right = null;
                return true;
            }
        }

        return (this.left != null && this.left.remove(id)) || (this.right != null && this.right.remove(id));
    }
}



```

# 树结构的实际应用

## 堆排序

堆排序基本介绍

1. 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为o（nlogn），它也是不稳定排序。
2. 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆，注意：没有要求结点的左孩子的值和右孩子的值的大小关系。
3. 每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆4）大顶堆举例说明

![image-20220118154648230](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220118154648230.png)

4. 小顶堆举例说明

![image-20220118155113207](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220118155113207.png)

5. 一般排序采用大顶堆，降序采用小顶堆



## **堆排序基本思想**

堆排序的基本思想是：

1. 将待排序序列构造成一个大顶堆

2. 此时，整个序列的最大值就是堆顶的根节点。

3. 将其与末尾元素进行交换，此时末尾就为最大值。

4. 然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。

   

   可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了.

图示：

原始的数组【4，6，8，5，9】

1. 假定给定无序序列结构如下

   ![image-20220118160007689](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220118160007689.png)

   

2. 此时我们从最后一个非叶子结开始（叶结点自然不用调整，第一个非叶子结点arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。

![image-20220119185654140](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220119185654140.png)

3. 找到第二个非叶节点4，由于[4，9，8]中9元素最大，4和9交换。

![image-20220119185952931](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220119185952931.png)

4. 这时，交换导致了子根[4，5，6]结构混乱，继续调整，[4，5，6]中6最大，交换4和6。

![image-20220119190137970](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220119190137970.png)

此时，我们就将一个无序序列构造成了一个大顶堆。

**步骤二将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。**

1. 将堆顶元素9和末尾元素4进行交换

![image-20220119190324308](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220119190324308.png)

2. 重新调整结构，使其继续满足堆定义

![image-20220119190405379](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220119190405379.png)

3. 再将堆顶元素8与未尾元素5进行交换，得到第二大元素8.

![image-20220119190443961](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220119190443961.png)

4. 后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序

![image-20220119190522296](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220119190522296.png)

基本思路

1. 将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆
2. 将堆顶元素与末尾元素交换，将最大元素“沉“到数组末端；
3. 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整
   +交换步骤，直到整个序列有序。

代码

```java
package com.wudidemiao.study.tree;

import java.util.Arrays;

/**
 * @author wudidemiaoa
 * @date 2022/1/19
 * @apiNote
 */
public class HeadSort {

    public static void main(String[] args) {
//        升序排列，进行大顶堆排序
        int[] arr = {4, 6, 8, 5, 9};
        headSort(arr);
    }

    //    堆排序的方法
    public static void headSort(int[] arr) {
        int tmp = 0;
        System.out.println("堆排序");
// 分布完成
//        adjustHead(arr, 1, arr.length);
//        System.out.println("第一次" + Arrays.toString(arr));  // 4 9 8 5 6
//
//        adjustHead(arr, 0, arr.length);
//        System.out.println("第二次" + Arrays.toString(arr));  // 9, 6, 8, 5, 4
        for (int i = arr.length / 2 - 1; i >= 0; i--) {
            adjustHead(arr, i, arr.length);
        }

        for (int j = arr.length - 1; j > 0; j--) {
//            交换
            tmp = arr[j];
            arr[j] = arr[0];
            arr[0] = tmp;
            adjustHead(arr, 0, j);
        }

        System.out.println("数组：" + Arrays.toString(arr));  // 9, 6, 8, 5, 4
    }

    /**
     * 将一个数组（二叉树），调整成一颗大顶堆，
     * <p>
     * 将以i对应的非叶子节点的树调整为大顶堆
     *
     * @param arr    待调整的数组
     * @param i      表示非叶子节点在数组中的索引
     * @param length 表示对多少个元素进行调整，length 实在逐渐的减小
     */
    public static void adjustHead(int arr[], int i, int length) {
// 取出当前元素的值
        int temp = arr[i];
//        开始调整
//        i1= i*2+1 i1是i节点的左子节点
        for (int i1 = i * 2 + 1; i1 < length; i1 = i1 * 2 + 1) {
            if (i1 + 1 < length && arr[i1] < arr[i1 + 1]) {  // 说明左子节点的值小于右子节点的值
                i1++;  // k指向
            }
            if (arr[i1] > temp) {  // 如果子节点大于夫节点
                arr[i] = arr[i1];  // 把较大的值付给当前节点
                i = i1;     // 把i指向i1，持续循环比较
            } else {
                break;
            }
        }

//        当for循环结束后，我们将i为夫节点的树的最大值，放在u最前面（局部）
        arr[i] = temp;
    }
}

```

## 赫夫曼树

### 基本介绍

1. 给定n个权值作为n个叶子结点，构造一棵二又树，若该树的带权路径长度（wpl）达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树（Huffman Tree），还有的书翻译为霍夫曼树。
2. 赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。

### 赫去曼树几个重要概念和举例说明

1. 路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1
2. 结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积
3. 树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL（weighted path length），权值越大的结点离根结点越近的二叉树才是最优二叉树。
4. WPL最小的就是赫夫曼树

![image-20220119204308036](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220119204308036.png)

### 赫夫曼树创建思路图解

给你一个数列{13，7，8，3，29，6，1}，要求转成一颗赫夫曼树.

思路分析：

​	构建赫夫曼树得步奏

	1. 从小到大进行排序，将每一个数据，每个数据都是一个节点，每个节点可以看成是一颗最简单得二叉树
	2. 取出根节点权值最小的两颗二叉树
	3. 组成一颗新的二叉树，该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和
	4. 再将这颗新的二叉树，以根节点的权值大小再次排序，不断重复1-2-3-4 的步奏，直到数列中，所有的数据源都被处理，就得到一颗赫夫曼树。



**图示**

![image-20220119210544300](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220119210544300.png)

![image-20220119210610607](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220119210610607.png)

![image-20220119210739515](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220119210739515.png)

![image-20220119210958973](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220119210958973.png)

### 代码创建赫夫曼树

```java
package com.wudidemiao.study.huffmantree;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

/**
 * @author wudidemiaoa
 * @date 2022/1/19
 * @apiNote
 */
public class HuffmanTree {
    public static void main(String[] args) {
        int arr[] = {13, 7, 8, 3, 29, 6, 1};
        Node huffmanTree = createHuffmanTree(arr);
    }

    //     创建赫夫曼树的方法
    public static Node createHuffmanTree(int arr[]) {
//      1.  遍历arr数组
//      2.  将arr的每个元素构建成每一个node
//        3.将Node 放入ArrayList中
        List<Node> nodes = new ArrayList<>();
        for (int i = 0; i < arr.length; i++) {
            nodes.add(new Node(arr[i]));
        }
        while (nodes.size() != 1) {
            Collections.sort(nodes);
            System.out.println("nodes=" + nodes);
//         去除权值最小的二叉树节点
            Node left = nodes.remove(0);
            Node right = nodes.remove(0);
            Node parents = new Node(left.value + right.value);
            parents.left = left;
            parents.right = right;
            nodes.add(parents);
        }
        return nodes.remove(0);
    }
}


// 创建节点类
// 为了让Node对象持续排序Collections 集合排序
class Node implements Comparable<Node> {
    //    权值
    int value;
    Node left; // 左子节点
    Node right;

    public Node(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    @Override
    public int compareTo(Node o) {
//        从小到大排序
        return this.value - o.value;
    }
}

```

## 赫夫曼编码



### **基本介绍**

1. 赫夫曼编码也翻译为哈夫曼编码（Huffman Coding），又称霍夫曼编码，是一种编码方式，属于一种程序算法
2. 赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。
3. 赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%~90%之间
4. 赫夫曼码是可变字长编码（VLC）的一种。Huffman于1952年提出一种编码方法，称之为最佳编码

### 原理刨析

> 通信领域中信息的处理方式1-定长编码

![image-20220119233352572](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220119233352572.png)

- 按照二进制来传递信息，总的长度是359（包括空格）
- [在线转码工具](https://www.mokuge.com/tool/ascito16/)

>通信领域中信息的处理方式2-变长编码

![image-20220119234535430](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220119234535430.png)

### 赫夫曼编码原理

>通信领域中信息的处理方式3-赫夫曼编码
>· i like like like java do you like a java//共40个字符（包括空格）
>· d：1y：1u：1j：2 v：20：21：4k：4e：4i：5a：5：9    //各个字符对应的个数
>· 按照上面字符出现的次数构建一颗赫夫曼树，次数作为权值.（图后）

![image-20220119235652533](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220119235652533.png)

> //根据赫夫曼树，给各个字符//规定编码，向左的路径为0/向右的路径为1，编码如下：
> o：1000 u：10010 d：100110y：100111 i：101
> a：110 k：1110 e：1111 j：0000 v：0001
> l：001：01
>
> 按照上面的赫夫曼编码，我们的“i like like like java do you like a java”字符串对应的编码为(前缀编码)（注意这里我们使用的无损压缩）
> 1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110
>
> 长度为：133说明：
> 1）原来长度是359，压缩了（359-133）/359=62.9%
> 2）此编码满足前缓编码，即字符的编码都不能是其他字符编码的前绷。不会造成匹配的多义性，无损的处理方案

注意，这个赫夫曼树根据排序方法不同，也可能不太一样，这样对应的赫夫曼编码也不完全一样，但是wpl是一样的，都是最小的，比如：如果我们让每次生成的新的二叉树总是排在权值相同的二又树的最后一个。

### 创建赫夫曼树思路

最佳实践-数据压缩（创建赫夫曼树）

将给出的一段文本，比如"i like like like java do you like a java"”，根据前面的讲的赫夫曼编码原理，对其进行数据压缩处理，

步骤1：根据赫夫曼编码压缩数据的原理，需要创建"i like like like java do you like a java”对应的赫夫曼树

思路：

1. 需要构建一个新的节点  Node{ data  存放数据 ,weight {权值} left 和right}
2. 得到字符串对应的byte[] 数组
3. 编写一个方法，将准备构建赫夫曼树的节点，放到list中，排序，然后来回构建赫夫曼树。当list中节点为1时退出，赫夫曼树构建成功

补充：补码-> 反码（符号位不变，减1得到反码）->原码（符号位不变，其他位取反，得到原码）

代码实现：和解码一起放在下面



### 赫夫曼编码->解码

最佳实践-数据解压（使用赫夫曼编码解码

使用赫夫曼编码来解码数据，具体要求是

1. 前面我们得到了赫夫曼编码和对应的编码byte[]即：[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]
2. 现在要求使用赫夫曼编码，行解码，又重新得到原来的字符串"i like like like java do you like a java

思路：解码过程，就是编码的一个逆向操作。

代码实现：

压缩文件解压文件

```java
package com.wudidemiao.study.huffmancode;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.*;

/**
 * @author wudidemiaoa
 * @date 2022/1/20
 * @apiNote
 */
public class HuffmanCode {
    public static void main(String[] args) {
//        String str = "i like like like java do you like a java";
//        huffmanZip(str.getBytes());
//        byte[] bytes = {-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28};
//        byte[] decode = decode(huffmanCodes, bytes);
//        System.out.println(new String(decode));
//        zipFile("F:\\测试文件夹\\风景 - 16.jpg", "F:\\测试文件夹\\1.zip");
        unZipFile("F:\\测试文件夹\\1.zip","F:\\测试文件夹\\dst.jpg");
    }

    public static void unZipFile(String srcFile, String dstFile) {
        try (//        创建文件的输入流
             FileInputStream is = new FileInputStream(srcFile);
             //        创建输出流
             FileOutputStream fileOutputStream = new FileOutputStream(dstFile);
             ObjectInputStream objectInputStream = new ObjectInputStream(is);) {
            byte[] o1 = (byte[])objectInputStream.readObject();
            Map<Byte,String> o = (Map<Byte,String>)objectInputStream.readObject();
            byte[] decode = decode(o, o1);
            fileOutputStream.write(decode);
            System.out.println("解压成功..");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 编写方法对文件进行压缩处理
     *
     * @param srcFile 源地址
     * @param dstFile 目标地址
     */
    public static void zipFile(String srcFile, String dstFile) {

        try ( //        创建文件的输入流
              FileInputStream is = new FileInputStream(srcFile);
              //        创建输出流
              FileOutputStream fileOutputStream = new FileOutputStream(dstFile);
              ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
        ) {
            byte[] bytes = new byte[is.available()];
//            读取文件
            is.read(bytes);
//            获取到对应的赫夫曼编码表
            byte[] bytes1 = huffmanZip(bytes);
//赫夫曼编码后的字节数组写进去
            objectOutputStream.writeObject(bytes1);
            //            这里我们可以以对象流的方式写入赫夫曼编码，是为了以后回复文件时使用
            objectOutputStream.writeObject(huffmanCodes);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

//    完成数据的解压
//    1. 先将处理后的字节数组重新先转为赫夫曼编码对应的二进制的字符串，
//    2. 赫夫曼编码对应的二进制的字符串=》 对照赫夫曼编码=》重新转为字符串

    /**
     * 完成对压缩数据的解码
     *
     * @param huffmanCodes 赫夫曼编码表
     * @param huffmanBytes 赫夫曼编码得到的字节数组
     * @return 原来的字符串对应的数组
     */
    public static byte[] decode(Map<Byte, String> huffmanCodes, byte[] huffmanBytes) {
        //.先得到 huffmanBytes对应的二进制的字符串，形式101010010111
        StringBuilder stringBuilder = new StringBuilder();
//        将byte数组转成而精致的字符串1
        for (int i = 0; i < huffmanBytes.length; i++) {
//            判断是不是最后一个字节
            boolean flag = (i == huffmanBytes.length - 1);
            String s = byteToBitString(!flag, huffmanBytes[i]);
            stringBuilder.append(s);
        }
//        System.out.println(stringBuilder.toString());
//       把字符串按照指定的和驸马编码进行解码
//        把赫夫曼编码表进行调换，因为反向查询  97->100
        Map<String, Byte> map = new HashMap<>();
        for (Map.Entry<Byte, String> stringByteEntry : huffmanCodes.entrySet()) {
            map.put(stringByteEntry.getValue(), stringByteEntry.getKey());
        }
//        创建一个集合，存放Byte
        List<Byte> bytes = new ArrayList<>();
        for (int i = 0; i < stringBuilder.length(); ) {
            int count = 1;  // 小的计数器
            boolean flag = true;
            Byte b = null;
            while (flag) {
//                取出一个字符
                String key = stringBuilder.substring(i, i + count);  // i不动，让count移动，直到匹配到一个字符
                if (map.containsKey(key)) {
                    b = map.get(key);
                    flag = false;
                } else {
                    count++;
                }
            }
            bytes.add(b);
            i += count;
        }

//        当for循环结束后List就存放了所有的字符
//        把List中的数据放到byte数组中并返回
        byte[] bytes1 = new byte[bytes.size()];
        for (int i = 0; i < bytes.size(); i++) {
            bytes1[i] = bytes.get(i);
        }
        return bytes1;
    }

    /**
     * 将一个byte转为二进制的字符串
     *
     * @param b
     * @param flag 如果是true表示需要补高位，反之不补
     * @return 是该b对应的二进制的字符串，（注意是按补码返回）
     */
    private static String byteToBitString(boolean flag, byte b) {
//        使用一个变量保存b
        int temp = b;
//       如果是正数我们还存在补高位
        if (flag)
            temp |= 256;
        String str = Integer.toBinaryString(temp); // 返回temp对应的二进制的补码
//        System.out.println(str);
        if (flag) {
            return str.substring(str.length() - 8);
        }
        return str;
    }

    /**
     * 使用一个方法将前面的方法封装起来，便于调用，
     *
     * @param bytes
     * @return 经过赫夫曼编码压缩后返回的byte数组
     */
    private static byte[] huffmanZip(byte bytes[]) {
        List<Node> nodes = getNodes(bytes);
//         根据nodes创建的赫夫曼树
        Node huffmanTree = getHuffmanTree(nodes);
//        对应的赫夫曼编码（根据赫夫曼树）
        getBinaryCode(huffmanTree, "", stringBuilder);
//        根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组
        return zip(bytes, huffmanCodes);
    }

    private static byte[] zip(byte[] bytes, Map<Byte, String> huffman) {
        StringBuilder stringBuilder = new StringBuilder();
        for (int i = 0; i < bytes.length; i++) {
            String str = huffman.get(bytes[i]);
            stringBuilder.append(str);
        }

//        将stringBuilder转位byte数组，长度
        int len = (stringBuilder.length() + 7) / 8;
//         创建1一个存储压缩后的byte数组
        byte[] by = new byte[len];
        int k = 0;
        for (int i = 0; i < stringBuilder.length(); i += 8) {  // 因为是每八位对应一个byte，所以步长应该是+8
            String strByte;
            if (i + 8 > stringBuilder.length()) {
                strByte = stringBuilder.substring(i);
            } else {
                strByte = stringBuilder.substring(i, i + 8);
            }
            by[k] = (byte) Integer.parseInt(strByte, 2);
            k++;
        }
        return by;
    }

    static StringBuilder stringBuilder = new StringBuilder();

    static Map<Byte, String> huffmanCodes = new HashMap<>();

    /**
     * 将传入的node节点的所有叶子节点的赫夫曼编码存放到huffmanCodes 集合中
     *
     * @param node          传入节点
     * @param code          路劲 ：左子节点. 0 右子节点  1
     * @param stringBuilder 适用于凭借路劲
     */
    private static void getBinaryCode(Node node, String code, StringBuilder stringBuilder) {
        StringBuilder stringBuilder1 = new StringBuilder(stringBuilder);
        stringBuilder1.append(code);
        if (node != null) {
            if (node.data == null) {
//                递归处理
//                向左递归
                getBinaryCode(node.left, "0", stringBuilder1);
                getBinaryCode(node.right, "1", stringBuilder1);
            } else {
//                叶子节点
                huffmanCodes.put(node.data, stringBuilder1.toString());
            }
        }
    }

    static List<Node> getNodes(byte[] strBytes) {
        List<Node> nodes = new ArrayList<>();
//      存储每一个byte出现的次数->map
        Map<Byte, Integer> counts = new HashMap<>();
        for (byte strByte : strBytes) {
            if (counts.containsKey(strByte)) {
                Integer integer = counts.get(strByte) + 1;
                counts.put(strByte, integer);
            } else {
                counts.put(strByte, 1);
            }
        }
//        把每个键值对转换成node对象，并加入nodes集合
        for (Map.Entry<Byte, Integer> byteIntegerEntry : counts.entrySet()) {
            nodes.add(new Node(byteIntegerEntry.getKey(), byteIntegerEntry.getValue()));
        }
        return nodes;
    }

    static Node getHuffmanTree(List<Node> nodes) {
        while (nodes.size() != 1) {
            Collections.sort(nodes);
//         去除权值最小的二叉树节点
            Node left = nodes.remove(0);
            Node right = nodes.remove(0);
            Node parents = new Node(null, left.weight + right.weight);
            parents.left = left;
            parents.right = right;
            nodes.add(parents);
        }
        return nodes.remove(0);
    }

    static class Node implements Comparable<Node> {
        Byte data;  // 存放的数据
        int weight;  // 权值  字符出现的次数
        Node left;
        Node right;

        public Node(Byte data, int weight) {
            this.data = data;
            this.weight = weight;
        }

        public void preOrder() {
            System.out.println(this);
            if (this.left != null) {
                this.left.preOrder();
            }

            if (this.right != null) {
                this.right.preOrder();
            }
        }

        @Override
        public int compareTo(Node o) {
            return this.weight - o.weight;
        }

        @Override
        public String toString() {
            return "Node{" +
                    "data=" + data +
                    ", weight=" + weight +
                    '}';
        }
    }
}
```

### 赫夫曼编码压缩文件注意事项

1. 如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化，比如视频，ppt等等文件[举例压一个p
2. 赫夫曼编码是按字节来处理的，因此可以处理所有的文件（二进制文件、文本文件）[举例压一个xm文件
3. 如果一个文件中的内容，厘复的数据不多，压缩效果也不会很明显

## 二叉排序树

**思路分析**

使用数组

1. 数组未排序，优点：直接在数组尾添加，速度快。缺点：查找速度慢.[示意图]
2. 数组排序，优点：可以使用二分查找，查找速度快，缺点：为了保证数组有序在添加新数据时，找到插入位置后，后面的数据需整体移动，速度慢。际意图]



使用链式存储-链表

不管链表是否有序，查找速度都馒，添加数据速度比数组快，不需要数据整体移动。

使用二叉排序树

### 介绍

二叉排序树：BT:（Binary Sort（Search）Tree对于二又排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大特别说明：如果有相同的值，可以将该节点放在左子节点或右子节点

比如针对前面的数据（7，3，10，12，5，1，9，对应的二叉排序树为

![image-20220120184636965](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220120184636965.png)

**二叉排序树**

二叉排序树创建和遍历

一个数组创建成对应的二叉排序树，并使用中序遍历二叉排序树，比如：数组为Ary（7，3，10，12，5，1，9），创建成对应的二叉排序树为

![image-20220120185136270](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220120185136270.png)

二叉树的删除

二叉排序树的删除情况比较复杂，有下面三种情况需要考虑

1. 删除叶子节点（比如：2，5，9，12）
2. 删除只有一颗子树的节点（比如：1）
3. 删除有两颗子树的节点.（比如：7，3，10）

![image-20220120191908193](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220120191908193.png)

图解二叉排序树删除节点的三种情况

1. 第一种，删除叶子节点

   1. 找到要删除的节点，targetNode
   2. 找到targetNode的父节点，parentNode
   3. 判断targetNode 是parentNode的左子节点还是右子节点，
   4. 根据前面的情况来对应删除

2. 第二种，删除只有一颗子树的节点

   1. 找到要删除节点，targetNode,
   2. 找到targetNode的父节点，parent
   3. 确定targetNode的子节点还是左子节点和右子节点
   4. targetNode 是parent 的左子节点还是右子结点
   5. 如果targetNode 是parent的左子结点
   6. targetNode 的子节点是左子结点
   7. parent.left = targetNode.left;执行删除操作

3. 第三种，删除有两颗字数的节点

   1. 找到要删除的节点，targetNode

   2. 找到targetNode 的父节点，parent

   3. 从targetNode的右子树找到最小的节点保存 temp = 12;

   4. 删除最小的节点

   5. targetNode.value=temp;

       



代码实现

```java
package com.wudidemiao.study.binarysorttree;

/**
 * @author wudidemiaoa
 * @date 2022/1/20
 * @apiNote
 */
public class BinarySortTreeDemo {
    public static void main(String[] args) {
        int[] arr = {7, 3, 10, 12, 5, 1, 9, 0};
        BinarySortTree tree = new BinarySortTree();
        for (int i : arr) {
            tree.add(i);
        }
        tree.infixOrder();
//        tree.delNode(2);
        tree.delNode(10);
        tree.infixOrder();
    }
}

class BinarySortTree {
    private Node head;

    //    查找要删除的节点
    public Node search(int value) {
        if (head == null) {
            return null;
        }
        return head.search(value);
    }

    //    查找要删除的节点的夫节点
    public Node searchParent(int value) {
        if (head == null) {
            return null;
        }
        return head.searchParent(value);
    }

    /**
     * 返回 以node为根节点的二叉排序树的最小节点的值
     * 删除node为根节点的二叉排序树的最小节点
     *
     * @param node 传入的节点（当作二叉排序树的根节点）
     * @return  返回的以node为根节点的二叉排序树的最小节点的值
     */
    public int delRight(Node node){
        Node target = node;
//        循环的查找左节点，就会找到最小值
        while (target.left !=null){
            target = target.left;
        }
//        这时target就指向最小节点
        delNode(target.value);
        return target.value;
    }

    public int delLeft(Node node){
        Node target = node;
//        循环的查找左节点，就会找到最小值
        while (target.right !=null){
            target = target.right;
        }
//        这时target就指向最小节点
        delNode(target.value);
        return target.value;
    }


    //    删除节点
    public void delNode(int value) {
        if (head == null) {
            return;
        }
//        需要先去找要删除的节点targetNode
        Node targetNode = search(value);
        if (targetNode == null) {
            return;
        }
//        如果发现当前这颗二叉排序树只有一个节点，
        if (head.left == null && head.right == null) {
            head = null;
            return;
        }

//        去查找targetNode的父节点
        Node parent = searchParent(value);
//        如果要删除的是叶子节点
        if (targetNode.left == null && targetNode.right == null) {
            if (parent.left != null && parent.left.value == value) {
                parent.left = null;
            } else if (parent.right != null && parent.right.value == value) {
                parent.right = null;
            }
            return;
        } else if (targetNode.left != null && targetNode.right != null) {  //删除目录下存在左右子树
            int minValue = delRight(targetNode.right);
            targetNode.value = minValue;
        } else { // 删除只有一颗子树的节点
            // 如果要删除的节点有左子节点
            if (targetNode.left != null) {
                if(parent==null){
                    head = targetNode.left;
                    return;
                }
                if (parent.left.value == value) {
                    parent.left = targetNode.left;
                } else if (parent.right.value == value) {
                    parent.right = targetNode.left;
                }
            } else {  // 要删除的节点有右子节点
                if(parent==null){
                    head = targetNode.right;
                    return;
                }
                if (parent.left.value == value) {
                    parent.left = targetNode.right;
                } else if (parent.right.value == value) {
                    parent.right = targetNode.right;
                }
            }
        }

    }

    public void add(int value) {
        if (head != null) {
            head.add(new Node(value));
        } else {
            head = new Node(value);
        }
    }

    public void infixOrder() {
        if (head != null) {
            head.infixOrder();
        } else {
            System.out.println("不能遍历");
        }
    }

}

class Node {
    int value;
    Node left;
    Node right;

    public Node(int value) {
        this.value = value;
    }

    /**
     * 查找要删除的节点
     *
     * @param value
     */
    public Node search(int value) {
        if (this.value == value) { // 找到该节点
            return this;
        } else if (this.value > value) {  // 如果查找的值小于当前节点，向左子树递归查找
            if (this.left == null) {
                return null;
            }
            return this.left.search(value);
        } else {
            if (this.right == null) {
                return null;
            }
            return this.right.search(value);
        }
    }

    /**
     * 查找要删除的节点的父节点
     *
     * @param value 要找的节点的值
     * @return 返回的是要删除的节点的父节点，如果没有就返回null;
     */
    public Node searchParent(int value) {
        if (this.value == value) {
            return null;
        }
        if ((this.left != null && this.left.value == value) || (this.right != null && this.right.value == value)) {
            return this;
        } else {
//            如果查找的值小于当前节点的值，并且当前节点的左子节点不为空
            if (value < this.value && this.left != null) {
                return this.left.searchParent(value);
            } else if ((value >= this.value && this.right != null)) {
                return this.right.searchParent(value);
            } else {
                return null;
            }
        }
    }

    public void add(Node node) {
        if (node == null) {
            return;
        }
        if (node.value < value) {
            if (left == null) {
                left = node;
            } else {
                this.left.add(node);
            }
        } else {
            if (right == null) {
                right = node;
            } else {
                this.right.add(node);
            }
        }
    }

    public void infixOrder() {
        if (left != null) {
            left.infixOrder();
        }
        System.out.println(this);
        if (right != null) {
            right.infixOrder();
        }
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }
}

```

## 平衡二叉树（AVL树）

看一个案例（说明二叉排序树可能的问题）

给你一个数列{1，2，34.5，6}，要求创建一颗二叉排序树BST），并分析问题所在

![image-20220120223436328](https://gitee.com/xu_guo_dong/images/raw/master/img/image-20220120223436328.png)

上边BST存在的问题分析：

1. 左子树全部为空，从形式上看，更像一个单链表
2. 插入速度没有影响
3. 查询速度明显降低因为需要依次比较），不能发挥BST的优势，因为每次还需要比较左子树，其查询速度比单链表还慢
4. 解决方案平衡二叉树（AVL）

### 基本介绍

1. 平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tre）又被称为AVL树，可以保证查询效率较高。
2. 具有以下特点：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树AⅥL、替罪羊树、Treap、伸展树等
3. 举例说明，看看下面哪些AⅥ树，为什么？